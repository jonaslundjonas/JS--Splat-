<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Splat! v0.7.3</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        body { margin: 0; overflow: hidden; background-color: #000; color: #fff; font-family: 'Courier New', Courier, monospace; }
        #gameCanvas { display: block; }
        #ui-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; align-items: center; }
        .ui-top { width: 100%; padding: 10px; box-sizing: border-box; pointer-events: auto; display: flex; justify-content: flex-start; align-items: center; background-color: rgba(0,0,0,0.5); }
        .ui-bottom { width: 100%; padding: 10px; box-sizing: border-box; pointer-events: auto; display: flex; justify-content: space-around; align-items: flex-end; background-color: rgba(0,0,0,0.7); min-height: 80px; }
        #healthContainer { display: flex; align-items: center; margin-right: 20px; }
        #healthBarOuter { width: 150px; height: 20px; background-color: #555; border: 1px solid #888; margin-right: 8px; padding: 2px; }
        #healthBarInner { width: 100%; height: 100%; background-color: #00cc00; transition: width 0.3s ease-out; }
        #healthText { font-size: 18px; text-shadow: 1px 1px 2px #000; min-width: 50px; }
        #scoreDisplay, #ammoDisplay, #weaponDisplay { font-size: 20px; margin: 5px 10px; text-shadow: 1px 1px 2px #000; }
        #scoreDisplay { margin-right: auto; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 2px; height: 15px; background-color: white; transform: translate(-50%, -50%); mix-blend-mode: difference; }
        #crosshair::before { content: ''; position: absolute; top: 50%; left: 50%; width: 15px; height: 2px; background-color: white; transform: translate(-50%, -50%); }
        #message-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background-color: rgba(0,0,0,0.85); color: white; text-align: center; font-family: 'Press Start 2P', 'Courier New', monospace; z-index: 10; pointer-events: auto; display: none; overflow: hidden; }
        #message-overlay h1#main-title { font-size: 6em; color: red; margin-bottom: 20px; text-shadow: 4px 4px #800000, 0 0 10px #ff4444; animation: rotateLogo 60s linear infinite alternate; position: relative; }
        @keyframes rotateLogo { 0% { transform: rotateY(-10deg) rotateX(5deg) scale(1); } 50% { transform: rotateY(10deg) rotateX(-3deg) scale(1.05); } 100% { transform: rotateY(-10deg) rotateX(5deg) scale(1); } }
        #message-overlay p#status-message { font-size: 1.5em; margin: 10px 0 30px 0; }
        #message-overlay .subtext#credits { font-size: 0.8em; margin-top: 30px; color: #aaa; position: absolute; bottom: 60px; width:100%; text-align:center; }
        #message-overlay button { font-family: 'Press Start 2P', 'Courier New', monospace; font-size: 1.2em; padding: 12px 25px; margin: 10px; background-color: #c00; color: white; border: 3px solid #f33; border-radius: 5px; cursor: pointer; text-transform: uppercase; box-shadow: 0 0 10px #f00, inset 0 0 5px rgba(255,100,100,0.5); transition: background-color 0.2s, transform 0.1s; }
        #message-overlay button:hover { background-color: #e00; transform: scale(1.05); }
        #message-overlay button:active { transform: scale(0.98); }
        #instruction-scroller-container { position: absolute; bottom: 0; left: 0; width: 100%; height: 40px; background-color: rgba(0,0,0,0.5); overflow: hidden; border-top: 2px solid #555; }
        #instruction-scroller { position: absolute; white-space: nowrap; font-size: 16px; line-height: 40px; font-family: 'Press Start 2P', 'Courier New', monospace; will-change: transform; }
        #game-message-center { position: absolute; top: 30%; left: 50%; transform: translateX(-50%); font-size: 24px; text-align: center; text-shadow: 2px 2px 4px #000; background-color: rgba(0,0,0,0.6); padding: 10px 15px; border-radius: 5px; display: none; pointer-events: none; z-index: 5; }
        #minimapContainer { position: absolute; top: 20px; right: 20px; width: 150px; height: 150px; border: 1px solid #555; background-color: rgba(0,0,0,0.6); pointer-events: none; }
        #minimapCanvas { width: 100%; height: 100%; }
        .status-effect-overlay { /* Combined class for freeze and poison */
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 9; 
            animation: pulseEffect 1s infinite alternate;
        }
        #frozen-player-overlay { background-color: rgba(100, 150, 255, 0.3); /* Light blue tint */ }
        #poisoned-player-overlay { background-color: rgba(100, 200, 100, 0.25); /* Light green tint */ }

        @keyframes pulseEffect { from { opacity: 0.25; } to { opacity: 0.5; } }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui-container">
        <div class="ui-top"><div id="healthContainer"><div id="healthBarOuter"><div id="healthBarInner"></div></div><div id="healthText">100%</div></div><div id="scoreDisplay">K:0</div></div>
        <div id="crosshair"></div><div id="game-message-center"></div>
        <div class="ui-bottom"><div id="weaponDisplay">W:Pistol</div><div id="ammoDisplay">A:âˆž</div></div>
    </div>
    <div id="minimapContainer"><canvas id="minimapCanvas"></canvas></div>
    <div id="message-overlay">
        <h1 id="main-title">Splat!</h1><p id="status-message">Click to Start</p>
        <div id="button-container"><button id="action-button">Start Game</button><button id="exit-button" style="display:none;">Exit to Title</button></div>
        <p class="subtext" id="credits">Written by Jonas Lund 2025</p>
        <div id="instruction-scroller-container"><div id="instruction-scroller">WASD:Move MOUSE:Aim/Shoot 1-4:Weapons Q/E:Look Destroy Demons! Collect Items! Survive! Stronger foes every 10 Kills!</div></div>
    </div>
    <div id="frozen-player-overlay" class="status-effect-overlay" style="display:none;"></div>
    <div id="poisoned-player-overlay" class="status-effect-overlay" style="display:none;"></div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- (Initial JS setup, constants, UI element getters, texture/audio functions - largely same) ---
        if (typeof THREE==='undefined'){document.body.innerHTML='<div style="color:red;text-align:center;padding-top:50px;font-size:24px;">Error: THREE.js failed to load.</div>';throw new Error("THREE.js not loaded");}
        console.log("Game script starting...");
        const TILE_SIZE=5,WALL_HEIGHT=4,PLAYER_HEIGHT=1.6,PLAYER_RADIUS=0.4,BASE_PLAYER_SPEED=5,MOUSE_SENSITIVITY=0.002;let currentPlayerSpeed=BASE_PLAYER_SPEED;const DEBUG_ENEMY_COLLIDER=false, DEBUG_DOOM_SPHERE_COLLIDER=false;
        const MAP_DATA=[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,2,0,0,0,0,0,0,3,0,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,0,0,1,0,1],[1,0,0,0,1,0,0,4,0,0,1,0,0,0,1],[1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,1,2,0,0,0,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,1],[1,0,0,0,0,0,0,1,3,0,0,0,0,0,1],[1,0,1,1,1,0,0,1,0,0,1,1,1,0,1],[1,0,0,0,1,0,1,1,1,0,1,4,0,0,1],[1,0,1,0,1,0,0,0,0,0,1,0,1,0,1],[1,0,1,2,0,0,1,0,1,0,0,0,1,0,1],[1,0,0,0,0,0,1,0,1,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]];
        let scene,camera,renderer,controls,player,gameManager,audioManager,doomSphere; const keys={};const bullets=[];const enemies=[];const temporaryEffects=[];let lastTime=performance.now();let gameRunning=false;
        const healthDisplayContainer=document.getElementById('healthContainer'),healthBarInner=document.getElementById('healthBarInner'),healthText=document.getElementById('healthText'),scoreDisplay=document.getElementById('scoreDisplay'),ammoDisplay=document.getElementById('ammoDisplay'),weaponDisplay=document.getElementById('weaponDisplay'),gameMessageCenter=document.getElementById('game-message-center'),minimapCanvas=document.getElementById('minimapCanvas'),minimapCtx=minimapCanvas.getContext('2d'),messageOverlay=document.getElementById('message-overlay'),mainTitle=document.getElementById('main-title'),statusMessage=document.getElementById('status-message'),actionButton=document.getElementById('action-button'),exitButton=document.getElementById('exit-button'),creditsText=document.getElementById('credits'),instructionScroller=document.getElementById('instruction-scroller'),instructionScrollerContainer=document.getElementById('instruction-scroller-container'),frozenPlayerOverlay=document.getElementById('frozen-player-overlay'),poisonedPlayerOverlay=document.getElementById('poisoned-player-overlay');
        let scrollerPosition=0;const scrollerSpeed=30;let lastScrollerTime=performance.now();const scrollerColors=['#ffcc00','#00ccff','#ccff00','#ff00cc','#ffffff'];let currentColorIndex=0;let lastColorChangeTime=performance.now();const colorChangeInterval=3000;let bounceOffset=0;let bounceDirection=1;const bounceSpeed=1.5;const maxBounce=3;
        function animateScroller(currentTime){if(messageOverlay.style.display!=='flex'||instructionScrollerContainer.style.display!=='block')return;const delta=(currentTime-lastScrollerTime)/1000;lastScrollerTime=currentTime;scrollerPosition-=scrollerSpeed*delta;const scrollerWidth=instructionScroller.offsetWidth;const containerWidth=instructionScrollerContainer.offsetWidth;if(scrollerPosition<-scrollerWidth)scrollerPosition=containerWidth;if(currentTime-lastColorChangeTime>colorChangeInterval){currentColorIndex=(currentColorIndex+1)%scrollerColors.length;instructionScroller.style.color=scrollerColors[currentColorIndex];lastColorChangeTime=currentTime;}bounceOffset+=bounceDirection*bounceSpeed*delta*10;if(bounceOffset>maxBounce||bounceOffset<-maxBounce){bounceDirection*=-1;bounceOffset=Math.max(-maxBounce,Math.min(maxBounce,bounceOffset));}instructionScroller.style.transform=`translateX(${scrollerPosition}px) translateY(${bounceOffset}px)`;}
        function createPixelTexture(c1,c2,s=32,p='c',d=4){const cv=document.createElement('canvas');cv.width=s;cv.height=s;const ctx=cv.getContext('2d');ctx.imageSmoothingEnabled=false;ctx.fillStyle=c1;ctx.fillRect(0,0,s,s);ctx.fillStyle=c2;const st=s/d;if(p==='c'){for(let y=0;y<d;y++)for(let x=0;x<d;x++)if((x+y)%2===0)ctx.fillRect(x*st,y*st,st,st)}else if(p==='lH'){for(let y=0;y<d;y+=2)ctx.fillRect(0,y*st,s,st)}else if(p==='lV'){for(let x=0;x<d;x+=2)ctx.fillRect(x*st,0,st,s)}else if(p==='b'){const bH=st;const bW=st*2;for(let r=0;r<d;r++)for(let c=0;c<d/2;c++){let oX=(r%2===0)?0:-bW/2;ctx.fillRect(c*bW+oX,r*bH,bW-1,bH-1);ctx.fillRect(c*bW+oX+bW,r*bH,bW-1,bH-1)}}const t=new THREE.CanvasTexture(cv);t.magFilter=THREE.NearestFilter;t.minFilter=THREE.NearestFilter;t.wrapS=THREE.RepeatWrapping;t.wrapT=THREE.RepeatWrapping;t.repeat.set(TILE_SIZE/2,WALL_HEIGHT/2);return t}
        function createEnemyTexture(baseColor='darkred',eyeColor='yellow',detailColor='#A00000',hornColor='#654321'){const cv=document.createElement('canvas');const sz=64;cv.width=sz;cv.height=sz;const ct=cv.getContext('2d');ct.imageSmoothingEnabled=false;ct.fillStyle=baseColor;ct.fillRect(sz*0.25,sz*0.3,sz*0.5,sz*0.6);ct.fillStyle=detailColor;ct.beginPath();ct.arc(sz*0.5,sz*0.2,sz*0.2,0,Math.PI*2);ct.fill();ct.fillStyle=eyeColor;ct.fillRect(sz*0.4,sz*0.15,sz*0.08,sz*0.08);ct.fillRect(sz*0.52,sz*0.15,sz*0.08,sz*0.08);ct.fillStyle=hornColor;ct.beginPath();ct.moveTo(sz*0.3,sz*0.1);ct.lineTo(sz*0.2,-sz*0.05);ct.lineTo(sz*0.35,sz*0.2);ct.fill();ct.beginPath();ct.moveTo(sz*0.7,sz*0.1);ct.lineTo(sz*0.8,-sz*0.05);ct.lineTo(sz*0.65,sz*0.2);ct.fill();const tx=new THREE.CanvasTexture(cv);tx.magFilter=THREE.NearestFilter;tx.minFilter=THREE.NearestFilter;return tx}
        const wallTexture=createPixelTexture('#444','#555',32,'b',4),floorTexture=createPixelTexture('#606','#656',32,'c',8),ceilingTexture=createPixelTexture('#303','#353',32,'lH',8);floorTexture.repeat.set(MAP_DATA[0].length,MAP_DATA.length);ceilingTexture.repeat.set(MAP_DATA[0].length,MAP_DATA.length);
        const enemyRedTexture=createEnemyTexture('darkred','yellow','#A00000'),enemyGreenTexture=createEnemyTexture('#004d00','#ffdd00','#006400','#556B2F'),enemyBlueTexture=createEnemyTexture('#00008B','#ADD8E6','#0000CD','#4682B4');
        const watcherTexture = createEnemyTexture('#400040', '#FF00FF', '#600060', '#300030'); 
        function createMuzzleFlashTexture(type='default'){const s=32;const cv=document.createElement('canvas');cv.width=s;cv.height=s;const ctx=cv.getContext('2d');ctx.imageSmoothingEnabled=false;const cX=s/2,cY=s/2;ctx.fillStyle='rgba(255,255,100,0.9)';if(type==='pistol'){for(let i=0;i<5;i++){ctx.beginPath();ctx.moveTo(cX,cY);ctx.lineTo(cX+Math.cos(i*2*Math.PI/5)*s*0.4,cY+Math.sin(i*2*Math.PI/5)*s*0.4);ctx.lineTo(cX+Math.cos((i+0.5)*2*Math.PI/5)*s*0.2,cY+Math.sin((i+0.5)*2*Math.PI/5)*s*0.2);ctx.closePath();ctx.fill();}}else if(type==='shotgun'){ctx.fillStyle='rgba(255,200,50,0.9)';for(let i=0;i<8;i++){const a=Math.random()*Math.PI*2;const l=s*(0.3+Math.random()*0.3);ctx.beginPath();ctx.moveTo(cX,cY);ctx.lineTo(cX+Math.cos(a)*l,cY+Math.sin(a)*l);ctx.lineTo(cX+Math.cos(a+0.2)*l*0.5,cY+Math.sin(a+0.2)*l*0.5);ctx.closePath();ctx.fill();}}else if(type==='machinegun'){ctx.fillStyle='rgba(255,255,150,0.85)';ctx.beginPath();ctx.moveTo(cX,cY);ctx.lineTo(s,cY-3);ctx.lineTo(s,cY+3);ctx.closePath();ctx.fill();ctx.beginPath();ctx.moveTo(cX,cY);ctx.lineTo(s*0.8,cY-2);ctx.lineTo(s*0.8,cY+2);ctx.closePath();ctx.fill();}else if(type==='plasma'){ctx.fillStyle='rgba(100,255,100,0.8)';ctx.beginPath();ctx.arc(cX,cY,s*0.35,0,Math.PI*2);ctx.fill();ctx.fillStyle='rgba(200,255,200,0.5)';ctx.beginPath();ctx.arc(cX,cY,s*0.45,0,Math.PI*2);ctx.fill();}else{ctx.beginPath();ctx.arc(cX,cY,s*0.4,0,Math.PI*2);ctx.fill();}const tx=new THREE.CanvasTexture(cv);tx.magFilter=THREE.NearestFilter;tx.minFilter=THREE.NearestFilter;return tx;}
        const muzzleFlashes={'Pistol':createMuzzleFlashTexture('pistol'),'Shotgun':createMuzzleFlashTexture('shotgun'),'MachineGun':createMuzzleFlashTexture('machinegun'),'PlasmaGun':createMuzzleFlashTexture('plasma'),'default':createMuzzleFlashTexture('default')};
        const decalTextures={bullet_hole:createPixelTexture('#222','#333',16,'c',2),energy_scorch:createPixelTexture('#FFA500','#FF4500',16,'lH',3)};decalTextures.bullet_hole.repeat.set(1,1);decalTextures.energy_scorch.repeat.set(1,1);

        class AudioManager { /* ... Updated watcher sound ... */
            constructor(){this.audioCtx=null;this.sounds={};this.masterGain=null;this.isInitialized=false;}
            async init(){if(this.isInitialized||!window.AudioContext&&!window.webkitAudioContext){console.warn("Web Audio API not supported or already initialized.");return;}this.audioCtx=new(window.AudioContext||window.webkitAudioContext)();this.masterGain=this.audioCtx.createGain();this.masterGain.gain.setValueAtTime(0.3,this.audioCtx.currentTime);this.masterGain.connect(this.audioCtx.destination);this.isInitialized=true;console.log("Audio Manager Initialized");}
            playSound(type,options={}){if(!this.isInitialized||!this.audioCtx)return;const oscillator=this.audioCtx.createOscillator();const gainNode=this.audioCtx.createGain();oscillator.connect(gainNode);gainNode.connect(this.masterGain);let duration=options.duration||0.1;gainNode.gain.setValueAtTime(options.volume||0.3,this.audioCtx.currentTime);switch(type){case 'pistol_shot':oscillator.type='triangle';oscillator.frequency.setValueAtTime(800,this.audioCtx.currentTime);oscillator.frequency.exponentialRampToValueAtTime(200,this.audioCtx.currentTime+duration*0.8);gainNode.gain.exponentialRampToValueAtTime(0.001,this.audioCtx.currentTime+duration);break;case 'shotgun_shot':oscillator.type='sawtooth';oscillator.frequency.setValueAtTime(400,this.audioCtx.currentTime);oscillator.frequency.exponentialRampToValueAtTime(100,this.audioCtx.currentTime+duration*0.9);gainNode.gain.setValueAtTime(options.volume||0.4,this.audioCtx.currentTime);gainNode.gain.exponentialRampToValueAtTime(0.001,this.audioCtx.currentTime+duration*1.2);duration=0.15;break;case 'machinegun_shot':oscillator.type='square';oscillator.frequency.setValueAtTime(1200,this.audioCtx.currentTime);oscillator.frequency.exponentialRampToValueAtTime(600,this.audioCtx.currentTime+duration*0.7);gainNode.gain.setValueAtTime(options.volume||0.15,this.audioCtx.currentTime);gainNode.gain.exponentialRampToValueAtTime(0.001,this.audioCtx.currentTime+duration);duration=0.07;break;case 'plasma_shot':oscillator.type='sine';oscillator.frequency.setValueAtTime(200,this.audioCtx.currentTime);oscillator.frequency.linearRampToValueAtTime(600,this.audioCtx.currentTime+duration*0.3);oscillator.frequency.linearRampToValueAtTime(150,this.audioCtx.currentTime+duration);gainNode.gain.setValueAtTime(options.volume||0.35,this.audioCtx.currentTime);gainNode.gain.exponentialRampToValueAtTime(0.001,this.audioCtx.currentTime+duration*1.1);duration=0.25;break;case 'enemy_explode':oscillator.type='sawtooth';oscillator.frequency.setValueAtTime(150,this.audioCtx.currentTime);oscillator.frequency.exponentialRampToValueAtTime(50,this.audioCtx.currentTime+duration*1.5);gainNode.gain.setValueAtTime(options.volume||0.5,this.audioCtx.currentTime);gainNode.gain.exponentialRampToValueAtTime(0.001,this.audioCtx.currentTime+duration*1.5);duration=0.4;break;case 'pickup':oscillator.type='triangle';oscillator.frequency.setValueAtTime(1000,this.audioCtx.currentTime);oscillator.frequency.linearRampToValueAtTime(1500,this.audioCtx.currentTime+duration*0.5);gainNode.gain.setValueAtTime(options.volume||0.25,this.audioCtx.currentTime);gainNode.gain.exponentialRampToValueAtTime(0.001,this.audioCtx.currentTime+duration);duration=0.1;break;case 'player_hit':oscillator.type='square';oscillator.frequency.setValueAtTime(300,this.audioCtx.currentTime);oscillator.frequency.exponentialRampToValueAtTime(100,this.audioCtx.currentTime+duration);gainNode.gain.setValueAtTime(options.volume||0.4,this.audioCtx.currentTime);gainNode.gain.exponentialRampToValueAtTime(0.001,this.audioCtx.currentTime+duration);duration=0.15;break;case 'freeze_hit':oscillator.type='sine';oscillator.frequency.setValueAtTime(1200,this.audioCtx.currentTime);oscillator.frequency.linearRampToValueAtTime(400,this.audioCtx.currentTime+duration);gainNode.gain.setValueAtTime(options.volume||0.3,this.audioCtx.currentTime);gainNode.gain.exponentialRampToValueAtTime(0.001,this.audioCtx.currentTime+duration);duration=0.3;break;case 'fire_shot':oscillator.type='sawtooth';oscillator.frequency.setValueAtTime(900,this.audioCtx.currentTime);oscillator.frequency.exponentialRampToValueAtTime(300,this.audioCtx.currentTime+duration);gainNode.gain.setValueAtTime(options.volume||0.2,this.audioCtx.currentTime);gainNode.gain.exponentialRampToValueAtTime(0.001,this.audioCtx.currentTime+duration*1.1);duration=0.08;break;
                    case 'watcher_poison_charge': // New sound for poison gas charge
                        oscillator.type = 'noise'; // Use noise for a hiss/gurgle
                        // For noise, frequency isn't directly set. We can use a bandpass filter if needed.
                        // Simple gain envelope for charge-up
                        gainNode.gain.setValueAtTime(0.01, this.audioCtx.currentTime);
                        gainNode.gain.linearRampToValueAtTime(options.volume || 0.25, this.audioCtx.currentTime + (options.duration || 1.0));
                        duration = options.duration || 1.0;
                        break;
                    case 'watcher_poison_spew': // New sound for gas release
                        oscillator.type = 'noise';
                        gainNode.gain.setValueAtTime(options.volume || 0.35, this.audioCtx.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioCtx.currentTime + duration);
                        duration = 0.4;
                        break;
                    case 'doom_sphere_bounce':oscillator.type='sine';oscillator.frequency.setValueAtTime(80,this.audioCtx.currentTime);oscillator.frequency.linearRampToValueAtTime(120,this.audioCtx.currentTime+duration*0.5);gainNode.gain.setValueAtTime(0.2,this.audioCtx.currentTime);gainNode.gain.exponentialRampToValueAtTime(0.001,this.audioCtx.currentTime+duration);duration=0.15;break;case 'doom_sphere_hit':oscillator.type='square';oscillator.frequency.setValueAtTime(600,this.audioCtx.currentTime);gainNode.gain.setValueAtTime(0.3,this.audioCtx.currentTime);gainNode.gain.exponentialRampToValueAtTime(0.001,this.audioCtx.currentTime+duration);duration=0.1;break;default:oscillator.type='noise';gainNode.gain.exponentialRampToValueAtTime(0.001,this.audioCtx.currentTime+duration);}oscillator.start(this.audioCtx.currentTime);oscillator.stop(this.audioCtx.currentTime+duration);}
            resumeContext(){if(this.audioCtx&&this.audioCtx.state==='suspended'){this.audioCtx.resume().then(()=>console.log("AudioContext resumed")).catch(e=>console.error("Error resuming AudioContext:",e));}}
        }

        class Player { /* ... Player.poisonPlayer added ... */
            constructor() {
                this.health = 100; this.maxHealth = 100;
                this.weapons = [ /* ... same weapon defs ... */ {name:'Pistol',ammo:Infinity,damage:50,fireRate:300,spread:0.02,pellets:1,isHitscan:true,automatic:false,sound:'pistol_shot',recoil:{x:0.01,y:0.02,duration:80}},{name:'Shotgun',ammo:20,maxAmmo:50,damage:15,fireRate:800,spread:0.15,pellets:8,isHitscan:true,automatic:false,sound:'shotgun_shot',recoil:{x:0.03,y:0.06,duration:150}},{name:'MachineGun',ammo:150,maxAmmo:300,damage:8,fireRate:70,spread:0.05,pellets:1,isHitscan:true,automatic:true,sound:'machinegun_shot',recoil:{x:0.005,y:0.01,duration:50}},{name:'PlasmaGun',ammo:50,maxAmmo:100,damage:100,fireRate:500,spread:0,pellets:1,projectileSpeed:35,isHitscan:false,automatic:false,aoeRadius:1.2,aoeDamage:15,sound:'plasma_shot',recoil:{x:0.02,y:0.03,duration:100}}];
                this.currentWeaponIndex = 0; this.lastShotTime = 0; this.isShooting = false;
                this.playerCollider = new THREE.Box3(); this.updateCollider();
                this.isFrozen = false; this.freezeTimer = 0; this.freezeDuration = 3; 
                this.isPoisoned = false; this.poisonTimer = 0; this.poisonDuration = 4; this.poisonDamage = 5;
                this.recoilOffset = new THREE.Vector2(); this.recoilReturnSpeed = 5; 
            }
            updateCollider() {this.playerCollider.setFromCenterAndSize(new THREE.Vector3(camera.position.x,camera.position.y-PLAYER_HEIGHT/2+0.1,camera.position.z),new THREE.Vector3(PLAYER_RADIUS*2,PLAYER_HEIGHT,PLAYER_RADIUS*2));}
            update(delta) { 
                if (this.isFrozen) { this.freezeTimer -= delta; if (this.freezeTimer <= 0) this.unfreeze(); }
                if (this.isPoisoned) { this.poisonTimer -=delta; if (this.poisonTimer <= 0) this.unpoison(); }
                this.handleRecoil(delta); 
            }
            handleRecoil(delta) {if(this.recoilOffset.lengthSq()>0.00001){const rAX=this.recoilOffset.x*this.recoilReturnSpeed*delta;const rAY=this.recoilOffset.y*this.recoilReturnSpeed*delta;const e=new THREE.Euler(0,0,0,'YXZ');e.setFromQuaternion(camera.quaternion);e.x-=rAY;e.y-=rAX;camera.quaternion.setFromEuler(e);this.recoilOffset.x-=rAX;this.recoilOffset.y-=rAY;}else{this.recoilOffset.set(0,0);}}
            applyRecoil(wpnRParams){if(!wpnRParams)return;const kX=(Math.random()-0.5)*wpnRParams.x*2;const kY=wpnRParams.y*(0.75+Math.random()*0.5);this.recoilOffset.x+=kX;this.recoilOffset.y+=kY;const e=new THREE.Euler(0,0,0,'YXZ');e.setFromQuaternion(camera.quaternion);e.x+=kY;e.y+=kX;e.x=Math.max(-Math.PI/2+0.1,Math.min(Math.PI/2-0.1,e.x));camera.quaternion.setFromEuler(e);}
            freezePlayer() { if(this.isFrozen)this.freezeTimer=this.freezeDuration; else{this.isFrozen=true;this.freezeTimer=this.freezeDuration;currentPlayerSpeed=BASE_PLAYER_SPEED*0.25;frozenPlayerOverlay.style.display='block';if(audioManager)audioManager.playSound('freeze_hit');showGameMessage("You are FROZEN!",this.freezeDuration*1000);}}
            unfreeze() { this.isFrozen=false;this.freezeTimer=0;if(!this.isPoisoned) currentPlayerSpeed=BASE_PLAYER_SPEED;frozenPlayerOverlay.style.display='none';} // Only restore full speed if not also poisoned
            poisonPlayer() {
                if (this.isPoisoned) this.poisonTimer = this.poisonDuration; // Refresh duration
                else {
                    this.isPoisoned = true;
                    this.poisonTimer = this.poisonDuration;
                    if (!this.isFrozen) currentPlayerSpeed = BASE_PLAYER_SPEED * 0.5; // Apply slow if not already frozen (freeze is stronger)
                    poisonedPlayerOverlay.style.display = 'block';
                    // audioManager.playSound('player_poisoned'); // Add a distinct sound for getting poisoned
                    showGameMessage("You are POISONED!", this.poisonDuration * 1000);
                }
                this.takeDamage(this.poisonDamage); // Immediate damage from gas
            }
            unpoison() {
                this.isPoisoned = false;
                this.poisonTimer = 0;
                if (!this.isFrozen) currentPlayerSpeed = BASE_PLAYER_SPEED; // Restore speed if not frozen
                poisonedPlayerOverlay.style.display = 'none';
            }
            shoot(currentTime) { /* ... same ... */
                const weapon = this.weapons[this.currentWeaponIndex];
                if (currentTime-this.lastShotTime < weapon.fireRate) return;
                if (weapon.ammo===0 && weapon.name!=='Pistol') return;
                this.lastShotTime = currentTime;
                if (weapon.name!=='Pistol') weapon.ammo--;
                this.applyRecoil(weapon.recoil); 
                const direction=new THREE.Vector3(); camera.getWorldDirection(direction);
                const muzzleFlashMaterial = new THREE.SpriteMaterial({ map: muzzleFlashes[weapon.name] || muzzleFlashes.default, transparent:true, blending: THREE.AdditiveBlending, depthWrite: false, sizeAttenuation:true});
                const muzzleFlash = new THREE.Sprite(muzzleFlashMaterial);
                const muzzleOffset=direction.clone().multiplyScalar(0.7); 
                muzzleFlash.position.copy(camera.position).add(muzzleOffset);
                let flashScale = (weapon.name === 'Shotgun' ? 0.9 : (weapon.name === 'PlasmaGun' ? 0.7 : 0.55));
                muzzleFlash.scale.set(flashScale, flashScale, 1); 
                scene.add(muzzleFlash);
                temporaryEffects.push({mesh:muzzleFlash,lifetime:0.06 + (weapon.name === 'Shotgun' ? 0.03 : 0)});
                if(audioManager) audioManager.playSound(weapon.sound);
                if (weapon.isHitscan) {
                    for (let i=0;i<weapon.pellets;i++) {
                        const spreadDirection=direction.clone();
                        spreadDirection.x+=(Math.random()-0.5)*weapon.spread; spreadDirection.y+=(Math.random()-0.5)*weapon.spread; spreadDirection.z+=(Math.random()-0.5)*weapon.spread;
                        spreadDirection.normalize();
                        const raycaster=new THREE.Raycaster(camera.position,spreadDirection,0.01,100);
                        const objectsToTest = enemies.filter(e=>e.health>0).map(e=>e.collisionMesh).concat(gameManager.walls);
                        if (doomSphere && !doomSphere.isDestroyed) objectsToTest.push(doomSphere.mesh);
                        const intersects = raycaster.intersectObjects(objectsToTest, false); 
                        const shotGeo = new THREE.SphereGeometry(0.05, 4, 4); 
                        const shotMat = new THREE.MeshBasicMaterial({color: 0xffefaa, transparent:true, opacity:0.9});
                        const shotMesh = new THREE.Mesh(shotGeo, shotMat);
                        shotMesh.position.copy(camera.position).add(muzzleOffset);
                        let hitPointForVisual = camera.position.clone().add(spreadDirection.clone().multiplyScalar(70));
                        if (intersects.length > 0) {
                            const hit = intersects[0];
                            hitPointForVisual = hit.point.clone();
                            if (hit.object.userData.isEnemyCollider && hit.object.userData.enemyInstance) {
                                hit.object.userData.enemyInstance.takeDamage(weapon.damage, hit.point);
                            } else if (hit.object.userData.isDoomSphere && hit.object.userData.sphereInstance) {
                                hit.object.userData.sphereInstance.takeDamage(weapon.damage, hit.point); 
                            } else if (hit.object.userData.isWall) {
                                createImpactDecal(hit.point, hit.face.normal, 'bullet_hole');
                            }
                        }
                        temporaryEffects.push({mesh:shotMesh, lifetime:0.08, velocity:spreadDirection.clone().multiplyScalar(200), isPhysicsParticle:true, target: hitPointForVisual, isVisualBullet: true});
                    }
                } else { 
                    const projectile = new Projectile(camera.position.clone().add(direction.clone().multiplyScalar(0.7)),direction.clone(),weapon.projectileSpeed,weapon.damage,true,weapon.aoeRadius,weapon.aoeDamage, 'plasma'); 
                    bullets.push(projectile); scene.add(projectile.mesh);
                }
                updateUI();
            }
            switchWeapon(idx){if(idx>=0&&idx<this.weapons.length){this.currentWeaponIndex=idx;updateUI();const newWeapon=this.weapons[this.currentWeaponIndex];if(newWeapon.automatic&&keys['MOUSE_LEFT']){this.isShooting=true;}else{this.isShooting=false;}}}
            takeDamage(amount){this.health-=amount;if(this.health<0)this.health=0;const dO=document.createElement('div');dO.style.cssText="position:absolute;top:0;left:0;width:100%;height:100%;background-color:rgba(255,0,0,0.3);pointer-events:none;";document.body.appendChild(dO);setTimeout(()=>document.body.removeChild(dO),100);if(audioManager)audioManager.playSound('player_hit');updateUI();if(this.health===0)gameManager.gameOver();}
            addHealth(amount){this.health=Math.min(this.health+amount,this.maxHealth);showGameMessage(`Health +${amount}!`,1500);if(audioManager)audioManager.playSound('pickup');updateUI();}
            addAmmo(weaponName,amount){const w=this.weapons.find(wp=>wp.name===weaponName);if(w&&w.name!=='Pistol'){w.ammo=Math.min(w.ammo+amount,w.maxAmmo);showGameMessage(`${w.name} Ammo +${amount}!`,1500);if(audioManager)audioManager.playSound('pickup',{frequency:1200});updateUI();}}
        }

        class Enemy { /* ... Watcher attack logic updated ... */
            constructor(position, type = 'red') { 
                this.type = type; this.enemySpecifics = gameManager.getEnemyStats(type);
                this.health = this.enemySpecifics.health; this.speed = this.enemySpecifics.speed; this.damage = this.enemySpecifics.damage;
                this.attackRange = 1.5; this.shootRange = this.enemySpecifics.shootRange || 20; 
                this.lastAttackTime = 0; this.attackCooldown = this.enemySpecifics.attackCooldown || 2000; 
                this.projectileType = this.enemySpecifics.projectileType || null; // e.g. 'fire', 'snowflake', 'poison_gas'
                this.scoreValue = this.enemySpecifics.scoreValue || 1;
                this.isAttacking = false; this.attackChargeTime = 0;
                let texture; if (type === 'green') texture = enemyGreenTexture; else if (type === 'blue') texture = enemyBlueTexture; else if (type === 'watcher') texture = watcherTexture; else texture = enemyRedTexture;
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true, sizeAttenuation: true }); this.spriteMesh = new THREE.Sprite(spriteMaterial); this.spriteMesh.position.copy(position); this.spriteMesh.position.y = (type === 'watcher') ? PLAYER_HEIGHT + 1.5 : PLAYER_HEIGHT / 2 - 0.3; this.spriteMesh.scale.set(type === 'watcher' ? 1.8 : 1.5, type === 'watcher' ? 1.8 : 1.5, 1.5); scene.add(this.spriteMesh);
                const enemyColliderWidth=(type==='watcher')?1.2:1.0,enemyColliderHeight=(type==='watcher')?1.2:1.6,enemyColliderDepth=(type==='watcher')?1.2:0.5;const collisionGeometry=new THREE.BoxGeometry(enemyColliderWidth,enemyColliderHeight,enemyColliderDepth);const collisionMaterial=new THREE.MeshBasicMaterial({visible:DEBUG_ENEMY_COLLIDER,wireframe:DEBUG_ENEMY_COLLIDER,color:(type==='blue'?0x00ffff:(type==='green'?0x00ff00:(type==='watcher'?0xff00ff:0xff00ff))),transparent:true,opacity:0.5});this.collisionMesh=new THREE.Mesh(collisionGeometry,collisionMaterial);this.collisionMesh.position.copy(this.spriteMesh.position);this.collisionMesh.userData={isEnemyCollider:true,enemyInstance:this};scene.add(this.collisionMesh);
            }
            update(delta, playerPosition) {
                if(this.health<=0)return;this.collisionMesh.position.copy(this.spriteMesh.position);
                const lookAtPosition = new THREE.Vector3(camera.position.x, this.spriteMesh.position.y, camera.position.z); 
                this.spriteMesh.lookAt(lookAtPosition);
                const directionToPlayer=new THREE.Vector3().subVectors(playerPosition,this.spriteMesh.position);const distanceToPlayer=directionToPlayer.length();directionToPlayer.normalize();let hasLOS=false;if(distanceToPlayer<this.shootRange*1.2){const raycaster=new THREE.Raycaster(this.spriteMesh.position,directionToPlayer,0,distanceToPlayer);const intersects=raycaster.intersectObjects(gameManager.walls);if(intersects.length===0||intersects[0].distance>=distanceToPlayer-0.1)hasLOS=true;}
                
                if(this.isAttacking && this.type === 'watcher'){
                    this.attackChargeTime -= delta;
                    const chargeProgress = 1 - (this.attackChargeTime / (this.enemySpecifics.gasChargeTime || 1.5));
                    const intensity = 0.4 + 0.6 * Math.sin(chargeProgress * Math.PI * 3 + performance.now() * 0.015); 
                    this.spriteMesh.material.color.setRGB(intensity * 0.5, intensity, intensity * 0.5); // Greenish pulsing for poison

                    if (this.attackChargeTime <= 0) { // Charge finished, spew gas
                        this.isAttacking = false; // Spew is instant, then cooldown
                        this.spriteMesh.material.color.setHex(0xffffff); // Reset color
                        this.fireWatcherPoisonGas(directionToPlayer); 
                        this.lastAttackTime = performance.now(); // Start cooldown after spew
                    }
                    return; 
                } else if (this.type === 'watcher' && !this.isAttacking) {
                     this.spriteMesh.material.color.setHex(0xffffff); 
                }

                if(hasLOS){if(this.type==='watcher'){const desiredDist=this.shootRange*0.7;if(distanceToPlayer>desiredDist+1)this.spriteMesh.position.add(directionToPlayer.clone().multiplyScalar(this.speed*delta*0.7));else if(distanceToPlayer<desiredDist-1)this.spriteMesh.position.add(directionToPlayer.clone().multiplyScalar(-this.speed*delta*0.5));const strafeDir=new THREE.Vector3(directionToPlayer.z,0,-directionToPlayer.x).normalize();this.spriteMesh.position.add(strafeDir.multiplyScalar(Math.sin(performance.now()*0.001+this.spriteMesh.uuid.charCodeAt(0))*this.speed*delta*0.3));this.spriteMesh.position.y=PLAYER_HEIGHT+1.5;}else{if(distanceToPlayer>this.attackRange*(this.type==='red'?1:0.8)){const moveVector=directionToPlayer.clone().multiplyScalar(this.speed*delta);this.spriteMesh.position.add(moveVector);this.spriteMesh.position.y=PLAYER_HEIGHT/2-0.3;}}if(distanceToPlayer<=this.shootRange&&(performance.now()-this.lastAttackTime>this.attackCooldown)){if(!this.isAttacking){this.attackPlayer(directionToPlayer);}}}
            }
            attackPlayer(directionToPlayer){
                if(this.type==='red'){const dir=new THREE.Vector3().subVectors(camera.position,this.spriteMesh.position).normalize();const rc=new THREE.Raycaster(this.spriteMesh.position,dir,0,this.attackRange*1.5);const wi=rc.intersectObjects(gameManager.walls);if(!wi.length||wi[0].distance>new THREE.Vector3().subVectors(camera.position,this.spriteMesh.position).length()){if(new THREE.Vector3().subVectors(camera.position,this.spriteMesh.position).length()<=this.attackRange*1.2){player.takeDamage(this.damage);const ap=new THREE.Mesh(new THREE.SphereGeometry(0.1,4,4),new THREE.MeshBasicMaterial({color:0xaa0000,transparent:true,opacity:0.6}));ap.position.copy(this.spriteMesh.position).add(dir.clone().multiplyScalar(0.5));scene.add(ap);temporaryEffects.push({mesh:ap,lifetime:0.1});}}}
                else if(this.type === 'watcher') {
                    this.isAttacking = true;
                    this.attackChargeTime = this.enemySpecifics.gasChargeTime || 1.5;
                    if(audioManager) audioManager.playSound('watcher_poison_charge', {duration: this.attackChargeTime, volume: 0.25});
                    this.lastAttackTime = performance.now() + this.attackChargeTime * 1000; // Prevent re-attack during charge
                }
                else if(this.projectileType){const projectile=new Projectile(this.spriteMesh.position.clone().add(directionToPlayer.clone().multiplyScalar(0.8)),directionToPlayer,this.enemySpecifics.projectileSpeed||20,this.enemySpecifics.projectileDamage||this.damage,false,0,0,this.projectileType);bullets.push(projectile);scene.add(projectile.mesh);if(this.projectileType==='fire'&&audioManager)audioManager.playSound('fire_shot');else if(this.projectileType==='snowflake'&&audioManager)audioManager.playSound('freeze_hit',{volume:0.2,duration:0.4});this.lastAttackTime = performance.now();}
            }
            fireWatcherPoisonGas(directionToPlayer) {
                if(audioManager) audioManager.playSound('watcher_poison_spew', {volume: 0.4});
                const gasProjectile = new Projectile(
                    this.spriteMesh.position.clone().add(directionToPlayer.clone().multiplyScalar(0.8)),
                    directionToPlayer,
                    this.enemySpecifics.gasProjectileSpeed || 8, // Slower gas cloud
                    0, // Damage is applied by poison effect on player
                    false, 0, 0, 'poison_gas'
                );
                bullets.push(gasProjectile);
                scene.add(gasProjectile.mesh);
            }
            takeDamage(amount,hitPoint){if(this.health<=0)return;this.health-=amount;createBloodSplat(hitPoint||this.spriteMesh.position,false,0.8+Math.random()*0.4);if(this.health<=0){this.health=0;this.die();}}
            die() {if(this.laserBeamMesh){scene.remove(this.laserBeamMesh);this.laserBeamMesh=null;clearInterval(this.laserHitCheckInterval);}scene.remove(this.spriteMesh); scene.remove(this.collisionMesh);const index=enemies.indexOf(this);if(index>-1)enemies.splice(index,1);gameManager.enemyKilled(this.scoreValue);if(audioManager)audioManager.playSound('enemy_explode');for(let i=0;i<20;i++){const offset=new THREE.Vector3((Math.random()-0.5)*1.5,(Math.random()-0.5)*1.5,(Math.random()-0.5)*1.5);createBloodSplat(this.spriteMesh.position.clone().add(offset),Math.random()>0.3,Math.random()*0.7+0.3);}for(let i=0;i<4;i++){const gibMat=new THREE.MeshBasicMaterial({color:0x6a0dad,transparent:true,opacity:0.9});const gibSz=Math.random()*0.2+0.1;const gibGeo=new THREE.BoxGeometry(gibSz,gibSz,gibSz);const gib=new THREE.Mesh(gibGeo,gibMat);gib.position.copy(this.spriteMesh.position);const gibVel=new THREE.Vector3((Math.random()-0.5)*7,Math.random()*5+2,(Math.random()-0.5)*7);scene.add(gib);temporaryEffects.push({mesh:gib,lifetime:0.7+Math.random()*0.5,velocity:gibVel,isPhysicsParticle:true});}if(this.type!=='red'){const dropType=Math.random()<0.5?'health_small':(Math.random()<0.5?'machinegun_ammo_small':'shotgun_ammo_small');gameManager.spawnDroppedPickup(this.spriteMesh.position.clone(),dropType);}else if(Math.random()<0.25){const dropTypeRoll=Math.random();let pickupType;if(dropTypeRoll<0.4)pickupType='health_small';else if(dropTypeRoll<0.65)pickupType='shotgun_ammo_small';else if(dropTypeRoll<0.85)pickupType='machinegun_ammo_small';else pickupType='plasma_ammo_small';gameManager.spawnDroppedPickup(this.spriteMesh.position.clone(),pickupType);}}
        }
        
        class Projectile { /* ... Added poison_gas type ... */
            constructor(pos,dir,spd,dmg,isPlayer,aoeR=0,aoeD=0, type = 'plasma'){ 
                this.type = type;this.pos=pos.clone();this.dir=dir.clone().normalize();this.spd=spd;this.dmg=dmg;this.isPlayer=isPlayer;this.aoeR=aoeR;this.aoeD=aoeD;this.life=(type==='poison_gas'?2.5:3); // Gas cloud lasts a bit less
                let geo, mat, size = 0.1;
                if (type === 'plasma') {geo=new THREE.SphereGeometry(size,6,6);mat=new THREE.MeshBasicMaterial({color:0x00dd00,emissive:0x00ff00,emissiveIntensity:0.8,transparent:true,opacity:0.9});} 
                else if (type === 'snowflake') {size = 0.15;geo=new THREE.OctahedronGeometry(size, 0);mat=new THREE.MeshStandardMaterial({color:0xADD8E6, emissive:0xADD8E6, emissiveIntensity:0.5, transparent:true, opacity:0.85, roughness:0.2, metalness:0.1});} 
                else if (type === 'fire') {size = 0.12;geo=new THREE.SphereGeometry(size,5,5);mat=new THREE.MeshBasicMaterial({color:0xffA500, emissive:0xff4500, emissiveIntensity:0.9, transparent:true, opacity:0.9});}
                else if (type === 'poison_gas') {
                    size = 0.3; // Larger cloud
                    geo = new THREE.SphereGeometry(size, 8, 6); // More complex sphere for cloud
                    // Create a canvas texture for the gas cloud
                    const gasCanvas = document.createElement('canvas'); gasCanvas.width = 64; gasCanvas.height = 64;
                    const gasCtx = gasCanvas.getContext('2d'); gasCtx.imageSmoothingEnabled = false;
                    const gasGradient = gasCtx.createRadialGradient(32,32,5, 32,32,30);
                    gasGradient.addColorStop(0, 'rgba(100,220,100,0.7)'); // Lighter green center
                    gasGradient.addColorStop(0.7, 'rgba(50,180,50,0.5)');
                    gasGradient.addColorStop(1, 'rgba(20,150,20,0.1)');
                    gasCtx.fillStyle = gasGradient; gasCtx.fillRect(0,0,64,64);
                    const gasTexture = new THREE.CanvasTexture(gasCanvas); gasTexture.magFilter = THREE.LinearFilter; gasTexture.minFilter = THREE.LinearFilter; // Smoother for gas
                    mat = new THREE.SpriteMaterial({map: gasTexture, transparent:true, blending: THREE.AdditiveBlending, sizeAttenuation:true, depthWrite:false});
                    this.mesh = new THREE.Sprite(mat); // Use Sprite for gas cloud
                    this.mesh.scale.set(size*3, size*3, 1); // Initial scale for sprite
                }
                if (!this.mesh) this.mesh=new THREE.Mesh(geo,mat); // Fallback if not sprite
                this.mesh.position.copy(this.pos);
                this.collider=new THREE.Sphere(this.pos,size);this.trailCounter=0; this.growthFactor = (type === 'poison_gas' ? 1.5 : 1);
            }
            update(delta){this.life-=delta;if(this.life<=0){this.destroy();return;}const moveDist=this.spd*delta;this.mesh.position.add(this.dir.clone().multiplyScalar(moveDist));this.collider.center.copy(this.mesh.position);this.trailCounter++;
                if (this.type === 'poison_gas') {
                    const scale = (0.3 + (2.5 - this.life) * 0.8) * this.growthFactor; // Expand then shrink slightly
                    this.mesh.scale.set(scale, scale, 1);
                    this.collider.radius = scale * 0.3; // Update collider radius with visual
                    this.mesh.material.opacity = Math.max(0, this.life / 2.5 * 0.7); // Fade out
                }
                else if(this.type==='plasma'&&this.trailCounter%2===0){const trailP=new THREE.Mesh(new THREE.SphereGeometry(0.05,4,4),new THREE.MeshBasicMaterial({color:0x00cc00,transparent:true,opacity:0.5}));trailP.position.copy(this.mesh.position).sub(this.dir.clone().multiplyScalar(0.2));scene.add(trailP);temporaryEffects.push({mesh:trailP,lifetime:0.15});}else if(this.type==='fire'&&this.trailCounter%1===0){const trailP=new THREE.Mesh(new THREE.SphereGeometry(0.04,3,3),new THREE.MeshBasicMaterial({color:0xff8c00,transparent:true,opacity:0.6}));trailP.position.copy(this.mesh.position).sub(this.dir.clone().multiplyScalar(0.15));scene.add(trailP);temporaryEffects.push({mesh:trailP,lifetime:0.1});}else if(this.type==='snowflake'&&this.trailCounter%3===0){const trailP=new THREE.Mesh(new THREE.SphereGeometry(0.03,3,3),new THREE.MeshBasicMaterial({color:0xD0FFFF,transparent:true,opacity:0.4}));trailP.position.copy(this.mesh.position).sub(this.dir.clone().multiplyScalar(0.1));scene.add(trailP);temporaryEffects.push({mesh:trailP,lifetime:0.2});}
                for(const w of gameManager.walls){if(this.collider.intersectsBox(new THREE.Box3().setFromObject(w))){this.handleImpact(this.mesh.position.clone());return;}}
                if(this.isPlayer){for(const e of enemies){if(e.health>0&&this.collider.intersectsBox(new THREE.Box3().setFromObject(e.collisionMesh))){this.handleImpact(e.collisionMesh.position.clone(),e);return;}}}
                else{if(player&&player.health>0&&this.collider.intersectsBox(player.playerCollider)){this.handleImpact(player.playerCollider.getCenter(new THREE.Vector3()),null,true);return;}}}
            handleImpact(impactPt,hitE=null,hitPlayer=false){
                if(this.type !== 'snowflake' && this.type !== 'poison_gas' || (hitPlayer && this.type !== 'poison_gas')){ // Gas doesn't make a big explosion decal
                    const explSize = this.aoeR > 0 ? this.aoeR : (this.type==='fire'?0.3:0.4);
                    const explColor = this.type==='fire'?0xff4500:0xffaa00;
                    const expl=new THREE.Mesh(new THREE.SphereGeometry(explSize,8,8),new THREE.MeshBasicMaterial({color:explColor,transparent:true,opacity:0.8}));expl.position.copy(impactPt);scene.add(expl);temporaryEffects.push({mesh:expl,lifetime:0.2});
                }
                if(hitPlayer){
                    if(this.type==='snowflake'){player.freezePlayer();}
                    else if (this.type === 'poison_gas') {player.poisonPlayer();}
                    else{player.takeDamage(this.dmg);}
                }else if(this.aoeR>0){if(this.isPlayer){enemies.forEach(e=>{if(e.health>0&&e.collisionMesh.position.distanceTo(impactPt)<=this.aoeR)e.takeDamage(this.aoeD,e.collisionMesh.position);});}}
                else if(hitE&&this.isPlayer){hitE.takeDamage(this.dmg,impactPt);}
                this.destroy();
            }
            destroy(){scene.remove(this.mesh);const i=bullets.indexOf(this);if(i>-1)bullets.splice(i,1);}
        }

        class Pickup { /* ... same ... */
            constructor(pos,type,isSmallDrop=false){this.type=type;this.mesh=null;this.collider=new THREE.Sphere(pos.clone(),isSmallDrop?0.4:0.6);this.collected=false;this.initialY=isSmallDrop?0.2:0.35;this.bobTime=Math.random()*Math.PI*2;let color,emissiveColor,boxSize=isSmallDrop?0.3:0.4;switch(type){case 'health':case 'health_small':color=0x00cc00;emissiveColor=0x00ff00;break;case 'shotgun_ammo':case 'shotgun_ammo_small':color=0xcc7a00;emissiveColor=0xff8c00;break;case 'machinegun_ammo_small':color=0x808080;emissiveColor=0xA9A9A9;break;case 'plasma_ammo':case 'plasma_ammo_small':color=0x0000cc;emissiveColor=0x3333ff;break;default:color=0xccc;emissiveColor=0xfff;}const geo=new THREE.BoxGeometry(boxSize,boxSize,boxSize);const mat=new THREE.MeshStandardMaterial({color:color,emissive:emissiveColor,emissiveIntensity:0.6,metalness:0.2,roughness:0.6});this.mesh=new THREE.Mesh(geo,mat);this.mesh.position.copy(pos);this.mesh.position.y=this.initialY;this.mesh.userData={isPickup:true,pickupInstance:this};scene.add(this.mesh);this.isSmallDrop=isSmallDrop;this.lifetime=isSmallDrop?10:Infinity;}
            collect(){if(this.collected)return;this.collected=true;scene.remove(this.mesh);const i=gameManager.pickups.indexOf(this);if(i>-1)gameManager.pickups.splice(i,1);switch(this.type){case 'health':player.addHealth(25);break;case 'health_small':player.addHealth(10);break;case 'shotgun_ammo':player.addAmmo('Shotgun',10);break;case 'shotgun_ammo_small':player.addAmmo('Shotgun',4);break;case 'machinegun_ammo_small':player.addAmmo('MachineGun',30);break;case 'plasma_ammo':player.addAmmo('PlasmaGun',20);break;case 'plasma_ammo_small':player.addAmmo('PlasmaGun',8);break;}}
            update(delta){if(this.collected)return;this.mesh.rotation.y+=delta*0.8;this.bobTime+=delta*2.5;this.mesh.position.y=this.initialY+Math.sin(this.bobTime)*0.1;if(this.isSmallDrop){this.lifetime-=delta;if(this.lifetime<=0){this.collected=true; scene.remove(this.mesh); const idx = gameManager.pickups.indexOf(this); if(idx > -1) gameManager.pickups.splice(idx,1); }}}
        }

        class DoomSphere { /* ... same ... */
            constructor(position) {this.hitsTaken = 0; this.maxHits = 5;this.speed = 4 + Math.random() * 1.5; this.radius = 0.7; this.respawnDelay = 4000; this.isDestroyed = false;const geometry = new THREE.SphereGeometry(this.radius, 16, 12);const dsCanvas=document.createElement('canvas');dsCanvas.width=64;dsCanvas.height=64;const dsCtx=dsCanvas.getContext('2d');dsCtx.imageSmoothingEnabled=false;dsCtx.fillStyle='#222';dsCtx.fillRect(0,0,64,64);dsCtx.strokeStyle='#cc0000';dsCtx.lineWidth=4;for(let i=0;i<6;i++){dsCtx.beginPath();dsCtx.arc(32,32,8+i*4,Math.random()*Math.PI*2,Math.random()*Math.PI*2);dsCtx.stroke();}dsCtx.fillStyle='rgba(255,50,0,0.5)';dsCtx.beginPath();dsCtx.arc(32,32,28,0,Math.PI*2);dsCtx.fill();const dsTexture=new THREE.CanvasTexture(dsCanvas);dsTexture.magFilter=THREE.NearestFilter;const material = new THREE.MeshStandardMaterial({map:dsTexture,emissive:0x990000,emissiveIntensity:0.8,metalness:0.7,roughness:0.25});this.mesh = new THREE.Mesh(geometry, material);this.mesh.position.copy(position);this.mesh.userData={isDoomSphere:true,sphereInstance:this};scene.add(this.mesh);this.velocity = new THREE.Vector3((Math.random()-0.5)*2,(Math.random()-0.5)*0.5,(Math.random()-0.5)*2).normalize().multiplyScalar(this.speed);this.collider = new THREE.Sphere(this.mesh.position, this.radius);if(DEBUG_DOOM_SPHERE_COLLIDER){const hG=new THREE.SphereGeometry(this.radius,8,8);const hM=new THREE.MeshBasicMaterial({color:0x00ff00,wireframe:true});this.debugMesh=new THREE.Mesh(hG,hM);this.debugMesh.position.copy(this.mesh.position);scene.add(this.debugMesh);}}
            update(delta) {if(this.isDestroyed)return;this.mesh.position.add(this.velocity.clone().multiplyScalar(delta));this.collider.center.copy(this.mesh.position);if(this.debugMesh)this.debugMesh.position.copy(this.mesh.position);this.mesh.rotation.x+=this.velocity.z*delta*0.2;this.mesh.rotation.y+=this.velocity.x*delta*0.2;gameManager.walls.forEach(wall=>{const wallBox=new THREE.Box3().setFromObject(wall);if(this.collider.intersectsBox(wallBox)){const cP=new THREE.Vector3();wallBox.clampPoint(this.mesh.position,cP);const n=new THREE.Vector3().subVectors(this.mesh.position,cP).normalize();if(n.lengthSq()>0.001){this.velocity.reflect(n);this.mesh.position.add(n.multiplyScalar(0.05));if(audioManager)audioManager.playSound('doom_sphere_bounce',{volume:0.15});}}});const mapBoundaryX=(MAP_DATA[0].length/2)*TILE_SIZE-this.radius,mapBoundaryZ=(MAP_DATA.length/2)*TILE_SIZE-this.radius;if(Math.abs(this.mesh.position.x)>mapBoundaryX){this.velocity.x*=-1;this.mesh.position.x=Math.sign(this.mesh.position.x)*(mapBoundaryX-0.01);if(audioManager)audioManager.playSound('doom_sphere_bounce',{volume:0.1});}if(Math.abs(this.mesh.position.z)>mapBoundaryZ){this.velocity.z*=-1;this.mesh.position.z=Math.sign(this.mesh.position.z)*(mapBoundaryZ-0.01);if(audioManager)audioManager.playSound('doom_sphere_bounce',{volume:0.1});}if(this.mesh.position.y<this.radius){this.mesh.position.y=this.radius+0.01;this.velocity.y=Math.abs(this.velocity.y)*0.85;if(audioManager)audioManager.playSound('doom_sphere_bounce',{volume:0.1});} if(this.mesh.position.y>WALL_HEIGHT-this.radius){this.mesh.position.y=WALL_HEIGHT-this.radius-0.01;this.velocity.y=-Math.abs(this.velocity.y)*0.85;if(audioManager)audioManager.playSound('doom_sphere_bounce',{volume:0.1});} if(player&&player.health>0&&this.collider.intersectsBox(player.playerCollider)){player.takeDamage(player.maxHealth+100);this.destroy(false);}}
            takeDamage(amountIgnored,hitPoint){if(this.isDestroyed)return;this.hitsTaken++;if(audioManager)audioManager.playSound('doom_sphere_hit',{volume:0.4});createImpactDecal(hitPoint||this.mesh.position,new THREE.Vector3(0,1,0),'energy_scorch');const originalColor=this.mesh.material.emissive.getHex();this.mesh.material.emissive.setHex(0xffffff);setTimeout(()=>{if(this.mesh&&this.mesh.material&&!this.isDestroyed)this.mesh.material.emissive.setHex(originalColor);},100);if(this.hitsTaken>=this.maxHits)this.destroy(true);}
            destroy(shouldRespawn){this.isDestroyed=true;scene.remove(this.mesh);if(this.debugMesh)scene.remove(this.debugMesh);for(let i=0;i<15;i++){const explGeo=new THREE.SphereGeometry(0.1+Math.random()*0.2,4,4);const explMat=new THREE.MeshBasicMaterial({color:0xff8800,transparent:true,opacity:0.9});const part=new THREE.Mesh(explGeo,explMat);part.position.copy(this.mesh.position);const vel=new THREE.Vector3((Math.random()-0.5)*15,(Math.random()-0.5)*15,(Math.random()-0.5)*15);temporaryEffects.push({mesh:part,lifetime:0.5+Math.random()*0.5,velocity:vel,isPhysicsParticle:true});scene.add(part);}if(audioManager)audioManager.playSound('enemy_explode',{volume:0.7});if(shouldRespawn){setTimeout(()=>gameManager.spawnDoomSphere(),this.respawnDelay);}doomSphere=null;}
        }
        
        class GameManager { /* ... Updated enemy type stats ... */
            constructor(){
                this.enemiesKilled=0;this.difficultyLevel=0;this.maxEnemies=5;this.enemySpawnInterval=4500;this.lastSpawnTime=0;this.walls=[];this.pickups=[];
                this.enemyTypes = {
                    'red': { health: 100, speed: 2.2, damage: 10, attackCooldown: 2000, scoreValue: 1, probability: 0.50 }, // Reduced red prob
                    'green': { health: 150, speed: 3.0, damage: 0, projectileType: 'fire', projectileSpeed: 28, projectileDamage: 12, attackCooldown: 700, shootRange: 22, scoreValue: 3, probability: 0.18 }, 
                    'blue': { health: 150, speed: 2.7, damage: 0, projectileType: 'snowflake', projectileSpeed: 20, projectileDamage: 5, attackCooldown: 2000, shootRange: 18, scoreValue: 3, probability: 0.17 },
                    'watcher': { health: 120, speed: 1.6, damage:0, projectileType: 'poison_gas', gasProjectileSpeed: 8, gasChargeTime: 1.2, attackCooldown: 3800, shootRange: 18, scoreValue: 5, probability: 0.15 } // Watcher now uses poison_gas
                };
            }
            getEnemyStats(type){const baseStats=this.enemyTypes[type]||this.enemyTypes['red'];return{...baseStats,health:Math.floor(baseStats.health*(1+this.difficultyLevel*0.15)),damage:Math.floor(baseStats.damage*(1+this.difficultyLevel*0.1)),projectileDamage:Math.floor((baseStats.projectileDamage||baseStats.damage)*(1+this.difficultyLevel*0.1)),speed:baseStats.speed*(1+this.difficultyLevel*0.05),};}
            enemyKilled(scoreValue=1){this.enemiesKilled+=scoreValue;this.updateDifficulty();updateUI();}
            updateDifficulty(){const nDL=Math.floor(this.enemiesKilled/10);if(nDL>this.difficultyLevel){this.difficultyLevel=nDL;this.maxEnemies=5+Math.floor(nDL*1.5);this.enemySpawnInterval=Math.max(800,4500-nDL*350);showGameMessage(`Difficulty Lvl ${this.difficultyLevel+1}! More Coming!`,2500);}}
            spawnEnemy(){if(enemies.length>=this.maxEnemies)return;let sX,sZ,vS=false;let att=0;while(!vS&&att<50){sX=Math.floor(Math.random()*MAP_DATA[0].length);sZ=Math.floor(Math.random()*MAP_DATA.length);if(MAP_DATA[sZ]&&MAP_DATA[sZ][sX]===0){const sP=new THREE.Vector3((sX-MAP_DATA[0].length/2)*TILE_SIZE+TILE_SIZE/2,0,(sZ-MAP_DATA.length/2)*TILE_SIZE+TILE_SIZE/2);if(camera&&sP.distanceTo(camera.position)>TILE_SIZE*3.5)vS=true;else if(!camera)vS=true;}att++;}if(vS){const p=new THREE.Vector3((sX-MAP_DATA[0].length/2)*TILE_SIZE+TILE_SIZE/2,0,(sZ-MAP_DATA.length/2)*TILE_SIZE+TILE_SIZE/2);let enemyType='red';const roll=Math.random();let cumulativeProb=0;const effectiveDifficulty=Math.min(this.difficultyLevel,5);cumulativeProb+=this.enemyTypes.watcher.probability*(effectiveDifficulty/3 + 0.2);if(roll<cumulativeProb)enemyType='watcher';else{cumulativeProb+=this.enemyTypes.blue.probability*(1+effectiveDifficulty*0.15);if(roll<cumulativeProb)enemyType='blue';else{cumulativeProb+=this.enemyTypes.green.probability*(1+effectiveDifficulty*0.15);if(roll<cumulativeProb)enemyType='green';}}enemies.push(new Enemy(p,enemyType));}}
            spawnDoomSphere() {if(doomSphere)return;let sX,sZ,vS=false;let att=0;while(!vS&&att<20){sX=Math.floor(Math.random()*(MAP_DATA[0].length-2))+1;sZ=Math.floor(Math.random()*(MAP_DATA.length-2))+1;if(MAP_DATA[sZ]&&MAP_DATA[sZ][sX]===0){const sP=new THREE.Vector3((sX-MAP_DATA[0].length/2)*TILE_SIZE+TILE_SIZE/2,PLAYER_HEIGHT,(sZ-MAP_DATA.length/2)*TILE_SIZE+TILE_SIZE/2);if(camera&&sP.distanceTo(camera.position)>TILE_SIZE*2.5)vS=true;}att++;}if(vS){const pos=new THREE.Vector3((sX-MAP_DATA[0].length/2)*TILE_SIZE+TILE_SIZE/2,PLAYER_HEIGHT+Math.random()*1.5,(sZ-MAP_DATA.length/2)*TILE_SIZE+TILE_SIZE/2);doomSphere=new DoomSphere(pos);}else{doomSphere=new DoomSphere(new THREE.Vector3(0,PLAYER_HEIGHT,0));}}
            spawnDroppedPickup(position,type){const pickup=new Pickup(position,type,true);this.pickups.push(pickup);}
            update(currentTime,delta){if(currentTime-this.lastSpawnTime>this.enemySpawnInterval){this.spawnEnemy();this.lastSpawnTime=currentTime;}for(let i=this.pickups.length-1;i>=0;i--)this.pickups[i].update(delta);if(doomSphere)doomSphere.update(delta);}
            showTitleScreen(){mainTitle.textContent="Splat!";statusMessage.textContent="Click to Blast!";actionButton.textContent="Start Game";actionButton.onclick=()=>this.startGame();exitButton.style.display='none';creditsText.style.display='block';instructionScrollerContainer.style.display='block';messageOverlay.style.display='flex';if(controls)controls.unlock();gameRunning=false;}
            startGame(){instructionScrollerContainer.style.display='none';messageOverlay.style.display='none';if(controls)controls.lock();if(player&&player.health===0)this.restartGameInternal();if(audioManager)audioManager.resumeContext();if(!doomSphere)this.spawnDoomSphere();}
            showPauseScreen(){mainTitle.textContent="Paused";statusMessage.textContent="Take a breather, Slayer...";actionButton.textContent="Resume";actionButton.onclick=()=>{instructionScrollerContainer.style.display='none';messageOverlay.style.display='none';if(controls)controls.lock();};exitButton.textContent="Exit to Title";exitButton.style.display='inline-block';exitButton.onclick=()=>{this.showTitleScreen();this.resetEntireGameForTitle();};creditsText.style.display='none';instructionScrollerContainer.style.display='none';messageOverlay.style.display='flex';}
            gameOver(){gameRunning=false;if(controls)controls.unlock();mainTitle.textContent="Game Over!";statusMessage.textContent=`You splatted ${this.enemiesKilled} demons!`;actionButton.textContent="Try Again?";actionButton.onclick=()=>this.restartGameInternal();exitButton.style.display='inline-block';exitButton.textContent="Back to Title";exitButton.onclick=()=>{this.showTitleScreen();this.resetEntireGameForTitle();};creditsText.style.display='none';instructionScrollerContainer.style.display='none';messageOverlay.style.display='flex';if(doomSphere){doomSphere.destroy(false);doomSphere=null;}}
            resetEntireGameForTitle(){temporaryEffects.forEach(eff=>scene.remove(eff.mesh));temporaryEffects.length=0;enemies.forEach(e=>{scene.remove(e.spriteMesh);scene.remove(e.collisionMesh);if(e.laserHitCheckInterval)clearInterval(e.laserHitCheckInterval);});enemies.length=0;bullets.forEach(b=>scene.remove(b.mesh));bullets.length=0;this.pickups.forEach(p=>scene.remove(p.mesh));this.pickups.length=0;if(doomSphere){doomSphere.destroy(false);doomSphere=null;}player=new Player();this.enemiesKilled=0;this.difficultyLevel=0;this.maxEnemies=5;this.enemySpawnInterval=5000;this.lastSpawnTime=0;const startPos=findStartPosition();if(camera){camera.position.set(startPos.x,PLAYER_HEIGHT,startPos.z);camera.rotation.set(0,0,0);}if(controls&&controls.euler){controls.euler.set(0,0,0,'YXZ');if(camera)camera.quaternion.setFromEuler(controls.euler);}buildLevel();buildLevelPickups();updateUI();currentPlayerSpeed=BASE_PLAYER_SPEED;player.unfreeze();player.unpoison();} // Ensure unpoison on full reset
            restartGameInternal(){console.log("Internal Restart...");this.resetEntireGameForTitle();instructionScrollerContainer.style.display='none';messageOverlay.style.display='none';if(controls)controls.lock();if(!doomSphere)this.spawnDoomSphere();}
        }
        
        function init() { /* ... same ... */
            console.log("Initializing game...");audioManager=new AudioManager();audioManager.init().catch(e=>console.error("Audio Init failed early:",e));
            scene=new THREE.Scene();scene.background=new THREE.Color(0x1a1a1a);scene.fog=new THREE.Fog(0x1a1a1a,TILE_SIZE*5,TILE_SIZE*10);
            camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);const sP=findStartPosition();camera.position.set(sP.x,PLAYER_HEIGHT,sP.z);
            renderer=new THREE.WebGLRenderer({canvas:document.getElementById('gameCanvas'),antialias:false});renderer.setSize(window.innerWidth,window.innerHeight);renderer.setPixelRatio(window.devicePixelRatio*0.75);
            const aL=new THREE.AmbientLight(0x808080);scene.add(aL);const dL=new THREE.DirectionalLight(0xffffff,0.6);dL.position.set(1,1.5,1).normalize();scene.add(dL);dL.castShadow=true;renderer.shadowMap.enabled=true;
            player=new Player();gameManager=new GameManager();controls=new PointerLockControls(camera,document.body);scene.add(controls.getObject());
            gameManager.showTitleScreen();
            if(controls){controls.addEventListener('lock',()=>{console.log("Controls locked.");if(messageOverlay.style.display!=='none'&&actionButton.textContent!=="Try Again?")messageOverlay.style.display='none';instructionScrollerContainer.style.display='none';gameRunning=true;lastTime=performance.now();if(audioManager)audioManager.resumeContext();});controls.addEventListener('unlock',()=>{console.log("Controls unlocked.");if(player&&player.health>0&&gameRunning)gameManager.showPauseScreen();gameRunning=false;});}
            buildLevel();buildLevelPickups();minimapCanvas.width=minimapCanvas.offsetWidth;minimapCanvas.height=minimapCanvas.offsetHeight;
            window.addEventListener('resize',onWindowResize,false);
            document.addEventListener('keydown',(e)=>{keys[e.code.toUpperCase()]=true;});
            document.addEventListener('keyup',(e)=>{keys[e.code.toUpperCase()]=false;});
            document.addEventListener('mousedown',(e)=>{if(controls&&controls.isLocked&&e.button===0&&player){keys['MOUSE_LEFT']=true;player.isShooting=true;const weapon=player.weapons[player.currentWeaponIndex];if(!weapon.automatic)player.shoot(performance.now());}if(audioManager)audioManager.resumeContext();});
            document.addEventListener('mouseup',(e)=>{if(e.button===0&&player){keys['MOUSE_LEFT']=false;if(player.weapons[player.currentWeaponIndex].automatic)player.isShooting=false;}});
            updateUI();console.log("Init complete.");
        }

        function findStartPosition(){for(let z=0;z<MAP_DATA.length;z++)for(let x=0;x<MAP_DATA[0].length;x++)if(MAP_DATA[z][x]===0)return{x:(x-MAP_DATA[0].length/2)*TILE_SIZE+TILE_SIZE/2,z:(z-MAP_DATA.length/2)*TILE_SIZE+TILE_SIZE/2};return{x:0,z:0};}
        function buildLevel(){const wG=new THREE.BoxGeometry(TILE_SIZE,WALL_HEIGHT,TILE_SIZE);const wM=new THREE.MeshLambertMaterial({map:wallTexture});gameManager.walls.forEach(w=>scene.remove(w));gameManager.walls=[];for(let z=0;z<MAP_DATA.length;z++)for(let x=0;x<MAP_DATA[0].length;x++)if(MAP_DATA[z][x]===1){const w=new THREE.Mesh(wG,wM);w.position.set((x-MAP_DATA[0].length/2)*TILE_SIZE+TILE_SIZE/2,WALL_HEIGHT/2,(z-MAP_DATA.length/2)*TILE_SIZE+TILE_SIZE/2);w.userData.isWall=true;scene.add(w);gameManager.walls.push(w);}const fG=new THREE.PlaneGeometry(MAP_DATA[0].length*TILE_SIZE,MAP_DATA.length*TILE_SIZE);const fM=new THREE.MeshLambertMaterial({map:floorTexture});const fl=new THREE.Mesh(fG,fM);fl.rotation.x=-Math.PI/2;scene.add(fl);const cG=new THREE.PlaneGeometry(MAP_DATA[0].length*TILE_SIZE,MAP_DATA.length*TILE_SIZE);const cM=new THREE.MeshLambertMaterial({map:ceilingTexture});const ce=new THREE.Mesh(cG,cM);ce.position.y=WALL_HEIGHT;ce.rotation.x=Math.PI/2;scene.add(ce);}
        function buildLevelPickups(){gameManager.pickups.forEach(p=>scene.remove(p.mesh));gameManager.pickups=[];for(let z=0;z<MAP_DATA.length;z++)for(let x=0;x<MAP_DATA[0].length;x++){const tT=MAP_DATA[z][x];const p=new THREE.Vector3((x-MAP_DATA[0].length/2)*TILE_SIZE+TILE_SIZE/2,0,(z-MAP_DATA.length/2)*TILE_SIZE+TILE_SIZE/2);let pT=null;if(tT===2)pT='health';else if(tT===3)pT='shotgun_ammo';else if(tT===4)pT='plasma_ammo';if(pT)gameManager.pickups.push(new Pickup(p,pT));}}
        class PointerLockControls extends THREE.EventDispatcher { /* ... same ... */ constructor(c,dE){super();this.camera=c;this.domElement=dE||document.body;this.isLocked=false;this.euler=new THREE.Euler(0,0,0,'YXZ');this.PI_2=Math.PI/2;this.minPolarAngle=0;this.maxPolarAngle=Math.PI;this._onMouseMove=this._onMouseMove.bind(this);this._onPointerlockChange=this._onPointerlockChange.bind(this);this._onPointerlockError=this._onPointerlockError.bind(this);this.connect();} _onMouseMove(e){if(this.isLocked===false)return;const mX=e.movementX||e.mozMovementX||e.webkitMovementX||0;const mY=e.movementY||e.mozMovementY||e.webkitMovementY||0;this.euler.setFromQuaternion(this.camera.quaternion);this.euler.y-=mX*MOUSE_SENSITIVITY;this.euler.x-=mY*MOUSE_SENSITIVITY;this.euler.x=Math.max(this.PI_2-this.maxPolarAngle,Math.min(this.PI_2-this.minPolarAngle,this.euler.x));this.camera.quaternion.setFromEuler(this.euler);this.dispatchEvent({type:'change'});} _onPointerlockChange(){if(document.pointerLockElement===this.domElement||document.mozPointerLockElement===this.domElement||document.webkitPointerLockElement===this.domElement){this.dispatchEvent({type:'lock'});this.isLocked=true;}else{this.dispatchEvent({type:'unlock'});this.isLocked=false;}} _onPointerlockError(e){console.error('PointerLockControls: Error.',e);} connect(){document.addEventListener('mousemove',this._onMouseMove,false);document.addEventListener('pointerlockchange',this._onPointerlockChange,false);document.addEventListener('mozpointerlockchange',this._onPointerlockChange,false);document.addEventListener('webkitpointerlockchange',this._onPointerlockChange,false);document.addEventListener('pointerlockerror',this._onPointerlockError,false);document.addEventListener('mozpointerlockerror',this._onPointerlockError,false);document.addEventListener('webkitpointerlockerror',this._onPointerlockError,false);} disconnect(){document.removeEventListener('mousemove',this._onMouseMove,false);document.removeEventListener('pointerlockchange',this._onPointerlockChange,false);document.removeEventListener('mozpointerlockchange',this._onPointerlockChange,false);document.removeEventListener('webkitpointerlockchange',this._onPointerlockChange,false);document.removeEventListener('pointerlockerror',this._onPointerlockError,false);document.removeEventListener('mozpointerlockerror',this._onPointerlockError,false);document.removeEventListener('webkitpointerlockerror',this._onPointerlockError,false);} dispose(){this.disconnect();} getObject(){return this.camera;} lock(){this.domElement.requestPointerLock=this.domElement.requestPointerLock||this.domElement.mozRequestPointerLock||this.domElement.webkitRequestPointerLock;if(this.domElement.requestPointerLock)this.domElement.requestPointerLock();else console.warn("requestPointerLock not available.");} unlock(){document.exitPointerLock=document.exitPointerLock||document.mozExitPointerLock||document.webkitExitPointerLock;if(document.exitPointerLock)document.exitPointerLock();else console.warn("exitPointerLock not available.");}}
        
        let minimapUpdateCounter = 0; const MINIMAP_UPDATE_INTERVAL = 5; 
        function animate() { /* ... same ... */
            requestAnimationFrame(animate); 
            const currentTime = performance.now(); 
            animateScroller(currentTime); 
            if (!gameRunning && messageOverlay.style.display === 'none') return; 
            if (!gameRunning && messageOverlay.style.display !== 'none') { renderer.render(scene,camera); return; }
            let delta = (currentTime - lastTime) / 1000; lastTime = currentTime; 
            if (delta > 0.1) delta = 0.1; 
            player.update(delta); handleInput(delta);
            if (player.isShooting && player.weapons[player.currentWeaponIndex].automatic){const w=player.weapons[player.currentWeaponIndex];if(currentTime-player.lastShotTime>=w.fireRate)player.shoot(currentTime);}
            for(let i=bullets.length-1;i>=0;i--)bullets[i].update(delta);
            enemies.forEach(e=>e.update(delta,camera.position));
            for(let i=temporaryEffects.length-1;i>=0;i--){const effect=temporaryEffects[i];effect.lifetime-=delta;if(effect.isPhysicsParticle&&effect.mesh){if(effect.isVisualBullet&&effect.target){const dirToTarget=new THREE.Vector3().subVectors(effect.target,effect.mesh.position).normalize();const distToTarget=effect.mesh.position.distanceTo(effect.target);const moveDist=Math.min(distToTarget,effect.velocity.length()*delta);effect.mesh.position.add(dirToTarget.multiplyScalar(moveDist));if(distToTarget<0.1)effect.lifetime=0;}else{effect.mesh.position.add(effect.velocity.clone().multiplyScalar(delta));effect.velocity.y-=15*delta;if(effect.target&&effect.mesh.position.distanceTo(effect.target)<0.2&&effect.lifetime>0.1)effect.lifetime=0.1;}if(effect.mesh.position.y<-1&&!effect.isVisualBullet)effect.lifetime=0;}if(effect.lifetime<=0){scene.remove(effect.mesh);temporaryEffects.splice(i,1);}}
            gameManager.update(currentTime,delta); if(player)player.updateCollider(); 
            minimapUpdateCounter++; if (minimapUpdateCounter >= MINIMAP_UPDATE_INTERVAL) { drawMinimap(); minimapUpdateCounter = 0; }
            renderer.render(scene,camera);
        }
        function handleInput(delta){ /* ... same ... */
            if(!controls||!controls.isLocked||!player)return;const mS=currentPlayerSpeed*delta;const pP=camera.position.clone();
            if(keys['KEYW'])controls.getObject().translateZ(-mS);if(keys['KEYS'])controls.getObject().translateZ(mS); 
            if(keys['KEYA'])controls.getObject().translateX(-mS);if(keys['KEYD'])controls.getObject().translateX(mS); 
            camera.position.y=PLAYER_HEIGHT;const tP=camera.position.clone();player.updateCollider();let cO=false;
            for(const w of gameManager.walls){if(player.playerCollider.intersectsBox(new THREE.Box3().setFromObject(w))){cO=true;break;}}
            if(cO){camera.position.copy(pP);camera.position.z=tP.z;player.updateCollider();let zC=false;for(const w of gameManager.walls)if(player.playerCollider.intersectsBox(new THREE.Box3().setFromObject(w))){zC=true;break;}if(zC)camera.position.z=pP.z;camera.position.x=tP.x;player.updateCollider();let xC=false;for(const w of gameManager.walls)if(player.playerCollider.intersectsBox(new THREE.Box3().setFromObject(w))){xC=true;break;}if(xC)camera.position.x=pP.x;player.updateCollider();}
            for(let i=gameManager.pickups.length-1;i>=0;i--){const p=gameManager.pickups[i];if(!p.collected&&player.playerCollider.intersectsSphere(p.collider))p.collect();}
            if(keys['DIGIT1'])player.switchWeapon(0);if(keys['DIGIT2'])player.switchWeapon(1);if(keys['DIGIT3'])player.switchWeapon(2);if(keys['DIGIT4'])player.switchWeapon(3);
            if(keys['KEYQ']) controls.getObject().rotation.y += BASE_PLAYER_SPEED * 0.005; 
            if(keys['KEYE']) controls.getObject().rotation.y -= BASE_PLAYER_SPEED * 0.005; 
        }
        
        function createBloodSplat(pos,lg=false,scM=1){const sM=new THREE.SpriteMaterial({color:0xff0000,transparent:true,opacity:0.9});const s=new THREE.Sprite(sM);s.position.copy(pos);s.position.x+=(Math.random()-0.5)*(lg?1:0.3);s.position.y+=(Math.random()-0.5)*(lg?1:0.3);s.position.z+=(Math.random()-0.5)*(lg?1:0.3);const sc=(Math.random()*0.3+0.1)*(lg?2:1)*scM;s.scale.set(sc,sc,sc);scene.add(s);temporaryEffects.push({mesh:s,lifetime:0.4+Math.random()*0.3});}
        function createImpactDecal(position, normal, type = 'bullet_hole') {const decalMaterial = new THREE.MeshBasicMaterial({map: decalTextures[type] || decalTextures.bullet_hole,transparent: true, opacity: 0.8,polygonOffset: true, polygonOffsetFactor: -4 });const decalSize = (type === 'energy_scorch') ? 0.5 : 0.25;const decalGeometry = new THREE.PlaneGeometry(decalSize, decalSize); const decal = new THREE.Mesh(decalGeometry, decalMaterial);decal.position.copy(position); decal.position.add(normal.clone().multiplyScalar(0.01)); decal.lookAt(position.clone().add(normal)); decal.rotation.z = Math.random() * Math.PI * 2; scene.add(decal); temporaryEffects.push({mesh:decal,lifetime:(type === 'energy_scorch' ? 3 : 5)}); }
        function drawMinimap() { /* ... same ... */ const mapWidth=MAP_DATA[0].length,mapHeight=MAP_DATA.length,miniTileSizeX=minimapCanvas.width/mapWidth,miniTileSizeY=minimapCanvas.height/mapHeight;minimapCtx.clearRect(0,0,minimapCanvas.width,minimapCanvas.height);for(let y=0;y<mapHeight;y++)for(let x=0;x<mapWidth;x++){if(MAP_DATA[y][x]===1)minimapCtx.fillStyle='#555';else if(MAP_DATA[y][x]>=2&&MAP_DATA[y][x]<=4)minimapCtx.fillStyle='#333';else minimapCtx.fillStyle='#222';minimapCtx.fillRect(x*miniTileSizeX,y*miniTileSizeY,miniTileSizeX,miniTileSizeY);}const worldToMinimap=(wX,wZ)=>{const mOX=-(mapWidth/2)*TILE_SIZE,mOZ=-(mapHeight/2)*TILE_SIZE;return{x:((wX-mOX)/(mapWidth*TILE_SIZE))*minimapCanvas.width,y:((wZ-mOZ)/(mapHeight*TILE_SIZE))*minimapCanvas.height};};if(player&&camera){const pP=worldToMinimap(camera.position.x,camera.position.z);minimapCtx.fillStyle='lime';minimapCtx.beginPath();minimapCtx.arc(pP.x,pP.y,3,0,Math.PI*2);minimapCtx.fill();const pD=new THREE.Vector3();camera.getWorldDirection(pD);minimapCtx.strokeStyle='lime';minimapCtx.lineWidth=1;minimapCtx.beginPath();minimapCtx.moveTo(pP.x,pP.y);minimapCtx.lineTo(pP.x+pD.x*8,pP.y+pD.z*8);minimapCtx.stroke();}enemies.forEach(e=>{if(e.health>0){const eP=worldToMinimap(e.spriteMesh.position.x,e.spriteMesh.position.z);let enemyColor='red';if(e.type==='green')enemyColor='lime';else if(e.type==='blue')enemyColor='cyan';else if(e.type==='watcher')enemyColor='#FF00FF';minimapCtx.fillStyle=enemyColor;minimapCtx.beginPath();minimapCtx.arc(eP.x,eP.y,2.5,0,Math.PI*2);minimapCtx.fill();}});if(doomSphere && !doomSphere.isDestroyed){const dsP = worldToMinimap(doomSphere.mesh.position.x, doomSphere.mesh.position.z); minimapCtx.fillStyle='#FFA500'; minimapCtx.beginPath(); minimapCtx.arc(dsP.x, dsP.y, 3.5, 0, Math.PI*2); minimapCtx.fill();}minimapCtx.fillStyle='cyan';gameManager.pickups.forEach(p=>{if(!p.collected&&!p.isSmallDrop){const pP=worldToMinimap(p.mesh.position.x,p.mesh.position.z);minimapCtx.fillRect(pP.x-2,pP.y-2,4,4);}});}
        function updateUI(){if(!player||!gameManager)return;const healthPercent=(player.health/player.maxHealth)*100;healthBarInner.style.width=`${healthPercent}%`;healthText.textContent=`${Math.round(healthPercent)}%`;if(healthPercent<30)healthBarInner.style.backgroundColor='#cc0000';else if(healthPercent<60)healthBarInner.style.backgroundColor='#cccc00';else healthBarInner.style.backgroundColor='#00cc00';const cW=player.weapons[player.currentWeaponIndex];weaponDisplay.textContent=`W:${cW.name.substring(0,6)}`;ammoDisplay.textContent=`A:${cW.ammo===Infinity?'âˆž':cW.ammo}`;scoreDisplay.textContent=`K:${gameManager.enemiesKilled}`;}
        function showGameMessage(txt,dur=1500){gameMessageCenter.textContent=txt; gameMessageCenter.style.display='block';setTimeout(()=>{if(gameMessageCenter.textContent===txt)gameMessageCenter.style.display='none';},dur);}
        function onWindowResize(){camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight);minimapCanvas.width=minimapCanvas.offsetWidth;minimapCanvas.height=minimapCanvas.offsetHeight;}
        init(); animate(); console.log("Loop started.");
    </script>
</body>
</html>
