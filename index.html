<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Splat!</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body { margin: 0; overflow: hidden; background-color: #000; color: #fff; font-family: 'Courier New', Courier, monospace; }
        #gameCanvas { display: block; }
        #ui-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; align-items: center; }
        .ui-top { 
            width: 100%; padding: 10px; box-sizing: border-box; pointer-events: auto;
            display: flex; /* Use flexbox for alignment */
            justify-content: flex-start; /* Align items to the start (left) */
            align-items: center; /* Vertically align items */
            background-color: rgba(0,0,0,0.5); 
        }
        .ui-bottom { width: 100%; padding: 10px; box-sizing: border-box; pointer-events: auto; display: flex; justify-content: space-around; align-items: flex-end; background-color: rgba(0,0,0,0.7); min-height: 80px; }
        
        #healthContainer {
            display: flex;
            align-items: center;
            margin-right: 20px; /* Space between health and score */
        }
        #healthBarOuter {
            width: 150px; /* Width of the health bar */
            height: 20px;
            background-color: #555;
            border: 1px solid #888;
            margin-right: 8px;
            padding: 2px; /* Padding to make inner bar not touch edges */
        }
        #healthBarInner {
            width: 100%; /* Starts full */
            height: 100%;
            background-color: #00cc00; /* Green for health */
            transition: width 0.3s ease-out;
        }
        #healthText { /* Percentage text */
            font-size: 18px;
            text-shadow: 1px 1px 2px #000;
            min-width: 50px; /* Ensure space for "100%" */
        }

        #scoreDisplay, #ammoDisplay, #weaponDisplay { 
            font-size: 20px; margin: 5px 10px; text-shadow: 1px 1px 2px #000; 
        }
        #scoreDisplay { margin-right: auto; /* Pushes weapon/ammo to the right if needed, or just next item */ }


        #crosshair { position: absolute; top: 50%; left: 50%; width: 2px; height: 15px; background-color: white; transform: translate(-50%, -50%); mix-blend-mode: difference; }
        #crosshair::before { content: ''; position: absolute; top: 50%; left: 50%; width: 15px; height: 2px; background-color: white; transform: translate(-50%, -50%); }
        
        #message-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background-color: rgba(0,0,0,0.85); color: white; text-align: center; font-family: 'Press Start 2P', 'Courier New', monospace; z-index: 10; pointer-events: auto; display: none; overflow: hidden; }
        #message-overlay h1#main-title { font-size: 6em; color: red; margin-bottom: 20px; text-shadow: 4px 4px #800000, 0 0 10px #ff4444; animation: rotateLogo 60s linear infinite alternate; position: relative; }
        @keyframes rotateLogo { 0% { transform: rotateY(-10deg) rotateX(5deg) scale(1); } 50% { transform: rotateY(10deg) rotateX(-3deg) scale(1.05); } 100% { transform: rotateY(-10deg) rotateX(5deg) scale(1); } }
        #message-overlay p#status-message { font-size: 1.5em; margin: 10px 0 30px 0; }
        #message-overlay .subtext#credits { font-size: 0.8em; margin-top: 30px; color: #aaa; position: absolute; bottom: 60px; width:100%; text-align:center; }
        #message-overlay button { font-family: 'Press Start 2P', 'Courier New', monospace; font-size: 1.2em; padding: 12px 25px; margin: 10px; background-color: #c00; color: white; border: 3px solid #f33; border-radius: 5px; cursor: pointer; text-transform: uppercase; box-shadow: 0 0 10px #f00, inset 0 0 5px rgba(255,100,100,0.5); transition: background-color 0.2s, transform 0.1s; }
        #message-overlay button:hover { background-color: #e00; transform: scale(1.05); }
        #message-overlay button:active { transform: scale(0.98); }
        #instruction-scroller-container { position: absolute; bottom: 0; left: 0; width: 100%; height: 40px; background-color: rgba(0,0,0,0.5); overflow: hidden; border-top: 2px solid #555; }
        #instruction-scroller { position: absolute; white-space: nowrap; font-size: 16px; line-height: 40px; font-family: 'Press Start 2P', 'Courier New', monospace; will-change: transform; }
        #game-message-center { position: absolute; top: 30%; left: 50%; transform: translateX(-50%); font-size: 24px; text-align: center; text-shadow: 2px 2px 4px #000; background-color: rgba(0,0,0,0.6); padding: 10px 15px; border-radius: 5px; display: none; pointer-events: none; z-index: 5; }
        #minimapContainer { position: absolute; top: 20px; right: 20px; width: 150px; height: 150px; border: 1px solid #555; background-color: rgba(0,0,0,0.6); pointer-events: none; }
        #minimapCanvas { width: 100%; height: 100%; }

        .frozen-overlay { /* For player frozen effect */
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(100, 150, 255, 0.3); /* Light blue tint */
            pointer-events: none;
            z-index: 9; /* Below UI messages but above game */
            animation: pulseFreeze 1s infinite alternate;
        }
        @keyframes pulseFreeze {
            from { opacity: 0.2; }
            to { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui-container">
        <div class="ui-top">
            <div id="healthContainer">
                <div id="healthBarOuter"><div id="healthBarInner"></div></div>
                <div id="healthText">100%</div>
            </div>
            <div id="scoreDisplay">K:0</div>
        </div>
        <div id="crosshair"></div><div id="game-message-center"></div>
        <div class="ui-bottom"><div id="weaponDisplay">W:Pistol</div><div id="ammoDisplay">A:&infin;</div></div>
    </div>
    <div id="minimapContainer"><canvas id="minimapCanvas"></canvas></div>
    <div id="message-overlay">
        <h1 id="main-title">Splat!</h1>
        <p id="status-message">Click to Start</p>
        <div id="button-container">
            <button id="action-button">Start Game</button>
            <button id="exit-button" style="display:none;">Exit to Title</button>
        </div>
        <p class="subtext" id="credits">Written by Jonas Lund 2025</p>
        <div id="instruction-scroller-container">
            <div id="instruction-scroller">
                Welcome Demon Slayer! Use WASD to Move, Mouse to Aim & Shoot. 1-4 to Switch Weapons. Q/E for alternative look. Destroy all incoming demons! Collect Health & Ammo. Good Luck! --- Enemies get stronger every 10 kills! --- Can you survive the SPLATOCALYPSE?!
            </div>
        </div>
    </div>
    <div id="frozen-player-overlay" class="frozen-overlay" style="display:none;"></div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- All JavaScript from the previous correct version goes here ---
        if (typeof THREE === 'undefined') { document.body.innerHTML = '<div style="color:red;text-align:center;padding-top:50px;font-size:24px;">Error: THREE.js failed to load.</div>'; throw new Error("THREE.js not loaded"); }
        console.log("Game script starting...");

        const TILE_SIZE=5, WALL_HEIGHT=4, PLAYER_HEIGHT=1.6, PLAYER_RADIUS=0.4, BASE_PLAYER_SPEED=5, MOUSE_SENSITIVITY=0.002; // Added BASE_PLAYER_SPEED
        let currentPlayerSpeed = BASE_PLAYER_SPEED; // For freeze effect
        const DEBUG_ENEMY_COLLIDER = false; 
        const MAP_DATA=[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,2,0,0,0,0,0,0,3,0,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,0,0,1,0,1],[1,0,0,0,1,0,0,4,0,0,1,0,0,0,1],[1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,1,2,0,0,0,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,1],[1,0,0,0,0,0,0,1,3,0,0,0,0,0,1],[1,0,1,1,1,0,0,1,0,0,1,1,1,0,1],[1,0,0,0,1,0,1,1,1,0,1,4,0,0,1],[1,0,1,0,1,0,0,0,0,0,1,0,1,0,1],[1,0,1,2,0,0,1,0,1,0,0,0,1,0,1],[1,0,0,0,0,0,1,0,1,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]];
        let scene,camera,renderer,controls,player,gameManager,audioManager; const keys={};const bullets=[];const enemies=[];const temporaryEffects=[];let lastTime=performance.now();let gameRunning=false;
        
        const healthDisplayContainer=document.getElementById('healthContainer'),healthBarInner=document.getElementById('healthBarInner'),healthText=document.getElementById('healthText'),
              scoreDisplay=document.getElementById('scoreDisplay'),ammoDisplay=document.getElementById('ammoDisplay'),weaponDisplay=document.getElementById('weaponDisplay'),
              gameMessageCenter=document.getElementById('game-message-center'), 
              minimapCanvas=document.getElementById('minimapCanvas'),minimapCtx=minimapCanvas.getContext('2d'),
              messageOverlay = document.getElementById('message-overlay'), mainTitle = document.getElementById('main-title'),
              statusMessage = document.getElementById('status-message'), actionButton = document.getElementById('action-button'),
              exitButton = document.getElementById('exit-button'), creditsText = document.getElementById('credits'),
              instructionScroller = document.getElementById('instruction-scroller'),
              instructionScrollerContainer = document.getElementById('instruction-scroller-container'),
              frozenPlayerOverlay = document.getElementById('frozen-player-overlay');

        let scrollerPosition = 0; const scrollerSpeed = 30; let lastScrollerTime = performance.now();
        const scrollerColors = ['#ffcc00', '#00ccff', '#ccff00', '#ff00cc', '#ffffff']; let currentColorIndex = 0;
        let lastColorChangeTime = performance.now(); const colorChangeInterval = 3000; 
        let bounceOffset = 0; let bounceDirection = 1; const bounceSpeed = 1.5; const maxBounce = 3; 

        function animateScroller(currentTime) { /* ... same ... */
            if (messageOverlay.style.display !== 'flex' || instructionScrollerContainer.style.display !== 'block') return; 
            const delta = (currentTime - lastScrollerTime) / 1000; lastScrollerTime = currentTime;
            scrollerPosition -= scrollerSpeed * delta;
            const scrollerWidth = instructionScroller.offsetWidth; const containerWidth = instructionScrollerContainer.offsetWidth;
            if (scrollerPosition < -scrollerWidth) scrollerPosition = containerWidth; 
            if (currentTime - lastColorChangeTime > colorChangeInterval) { currentColorIndex = (currentColorIndex + 1) % scrollerColors.length; instructionScroller.style.color = scrollerColors[currentColorIndex]; lastColorChangeTime = currentTime; }
            bounceOffset += bounceDirection * bounceSpeed * delta * 10; 
            if (bounceOffset > maxBounce || bounceOffset < -maxBounce) { bounceDirection *= -1; bounceOffset = Math.max(-maxBounce, Math.min(maxBounce, bounceOffset)); }
            instructionScroller.style.transform = `translateX(${scrollerPosition}px) translateY(${bounceOffset}px)`;
        }
        
        function createPixelTexture(c1,c2,s=32,p='c',d=4){const cv=document.createElement('canvas');cv.width=s;cv.height=s;const ctx=cv.getContext('2d');ctx.imageSmoothingEnabled=false;ctx.fillStyle=c1;ctx.fillRect(0,0,s,s);ctx.fillStyle=c2;const st=s/d;if(p==='c'){for(let y=0;y<d;y++)for(let x=0;x<d;x++)if((x+y)%2===0)ctx.fillRect(x*st,y*st,st,st)}else if(p==='lH'){for(let y=0;y<d;y+=2)ctx.fillRect(0,y*st,s,st)}else if(p==='lV'){for(let x=0;x<d;x+=2)ctx.fillRect(x*st,0,st,s)}else if(p==='b'){const bH=st;const bW=st*2;for(let r=0;r<d;r++)for(let c=0;c<d/2;c++){let oX=(r%2===0)?0:-bW/2;ctx.fillRect(c*bW+oX,r*bH,bW-1,bH-1);ctx.fillRect(c*bW+oX+bW,r*bH,bW-1,bH-1)}}const t=new THREE.CanvasTexture(cv);t.magFilter=THREE.NearestFilter;t.minFilter=THREE.NearestFilter;t.wrapS=THREE.RepeatWrapping;t.wrapT=THREE.RepeatWrapping;t.repeat.set(TILE_SIZE/2,WALL_HEIGHT/2);return t}
        
        function createEnemyTexture(baseColor = 'darkred', eyeColor = 'yellow', detailColor = '#A00000', hornColor = '#654321') {
            const cv = document.createElement('canvas'); const sz = 64; cv.width = sz; cv.height = sz;
            const ct = cv.getContext('2d'); ct.imageSmoothingEnabled = false;
            ct.fillStyle = baseColor; ct.fillRect(sz*0.25,sz*0.3,sz*0.5,sz*0.6); 
            ct.fillStyle = detailColor; ct.beginPath(); ct.arc(sz*0.5,sz*0.2,sz*0.2,0,Math.PI*2); ct.fill();
            ct.fillStyle = eyeColor; ct.fillRect(sz*0.4,sz*0.15,sz*0.08,sz*0.08); ct.fillRect(sz*0.52,sz*0.15,sz*0.08,sz*0.08);
            ct.fillStyle = hornColor; ct.beginPath(); ct.moveTo(sz*0.3,sz*0.1);ct.lineTo(sz*0.2,-sz*0.05);ct.lineTo(sz*0.35,sz*0.2);ct.fill();
            ct.beginPath();ct.moveTo(sz*0.7,sz*0.1);ct.lineTo(sz*0.8,-sz*0.05);ct.lineTo(sz*0.65,sz*0.2);ct.fill();
            const tx = new THREE.CanvasTexture(cv);
            tx.magFilter = THREE.NearestFilter; tx.minFilter = THREE.NearestFilter;
            return tx;
        }
        const wallTexture=createPixelTexture('#444','#555',32,'b',4),floorTexture=createPixelTexture('#606','#656',32,'c',8),ceilingTexture=createPixelTexture('#303','#353',32,'lH',8);floorTexture.repeat.set(MAP_DATA[0].length,MAP_DATA.length);ceilingTexture.repeat.set(MAP_DATA[0].length,MAP_DATA.length);
        const enemyRedTexture = createEnemyTexture('darkred', 'yellow', '#A00000');
        const enemyGreenTexture = createEnemyTexture('#004d00', '#ffdd00', '#006400', '#556B2F'); // Dark Green
        const enemyBlueTexture = createEnemyTexture('#00008B', '#ADD8E6', '#0000CD', '#4682B4'); // Dark Blue, Light Blue eyes

        class AudioManager { /* ... same ... */
            constructor(){this.audioCtx=null;this.sounds={};this.masterGain=null;this.isInitialized=false;}
            async init(){if(this.isInitialized||!window.AudioContext&&!window.webkitAudioContext){console.warn("Web Audio API not supported or already initialized.");return;}this.audioCtx=new(window.AudioContext||window.webkitAudioContext)();this.masterGain=this.audioCtx.createGain();this.masterGain.gain.setValueAtTime(0.3,this.audioCtx.currentTime);this.masterGain.connect(this.audioCtx.destination);this.isInitialized=true;console.log("Audio Manager Initialized");}
            playSound(type,options={}){if(!this.isInitialized||!this.audioCtx)return;const oscillator=this.audioCtx.createOscillator();const gainNode=this.audioCtx.createGain();oscillator.connect(gainNode);gainNode.connect(this.masterGain);let duration=options.duration||0.1;gainNode.gain.setValueAtTime(options.volume||0.3,this.audioCtx.currentTime);switch(type){case 'pistol_shot':oscillator.type='triangle';oscillator.frequency.setValueAtTime(800,this.audioCtx.currentTime);oscillator.frequency.exponentialRampToValueAtTime(200,this.audioCtx.currentTime+duration*0.8);gainNode.gain.exponentialRampToValueAtTime(0.001,this.audioCtx.currentTime+duration);break;case 'shotgun_shot':oscillator.type='sawtooth';oscillator.frequency.setValueAtTime(400,this.audioCtx.currentTime);oscillator.frequency.exponentialRampToValueAtTime(100,this.audioCtx.currentTime+duration*0.9);gainNode.gain.setValueAtTime(options.volume||0.4,this.audioCtx.currentTime);gainNode.gain.exponentialRampToValueAtTime(0.001,this.audioCtx.currentTime+duration*1.2);duration=0.15;break;case 'machinegun_shot':oscillator.type='square';oscillator.frequency.setValueAtTime(1200,this.audioCtx.currentTime);oscillator.frequency.exponentialRampToValueAtTime(600,this.audioCtx.currentTime+duration*0.7);gainNode.gain.setValueAtTime(options.volume||0.15,this.audioCtx.currentTime);gainNode.gain.exponentialRampToValueAtTime(0.001,this.audioCtx.currentTime+duration);duration=0.07;break;case 'plasma_shot':oscillator.type='sine';oscillator.frequency.setValueAtTime(200,this.audioCtx.currentTime);oscillator.frequency.linearRampToValueAtTime(600,this.audioCtx.currentTime+duration*0.3);oscillator.frequency.linearRampToValueAtTime(150,this.audioCtx.currentTime+duration);gainNode.gain.setValueAtTime(options.volume||0.35,this.audioCtx.currentTime);gainNode.gain.exponentialRampToValueAtTime(0.001,this.audioCtx.currentTime+duration*1.1);duration=0.25;break;case 'enemy_explode':oscillator.type='sawtooth';oscillator.frequency.setValueAtTime(150,this.audioCtx.currentTime);oscillator.frequency.exponentialRampToValueAtTime(50,this.audioCtx.currentTime+duration*1.5);gainNode.gain.setValueAtTime(options.volume||0.5,this.audioCtx.currentTime);gainNode.gain.exponentialRampToValueAtTime(0.001,this.audioCtx.currentTime+duration*1.5);duration=0.4;break;case 'pickup':oscillator.type='triangle';oscillator.frequency.setValueAtTime(1000,this.audioCtx.currentTime);oscillator.frequency.linearRampToValueAtTime(1500,this.audioCtx.currentTime+duration*0.5);gainNode.gain.setValueAtTime(options.volume||0.25,this.audioCtx.currentTime);gainNode.gain.exponentialRampToValueAtTime(0.001,this.audioCtx.currentTime+duration);duration=0.1;break;case 'player_hit':oscillator.type='square';oscillator.frequency.setValueAtTime(300,this.audioCtx.currentTime);oscillator.frequency.exponentialRampToValueAtTime(100,this.audioCtx.currentTime+duration);gainNode.gain.setValueAtTime(options.volume||0.4,this.audioCtx.currentTime);gainNode.gain.exponentialRampToValueAtTime(0.001,this.audioCtx.currentTime+duration);duration=0.15;break;case 'freeze_hit':oscillator.type='sine';oscillator.frequency.setValueAtTime(1200,this.audioCtx.currentTime);oscillator.frequency.linearRampToValueAtTime(400,this.audioCtx.currentTime+duration);gainNode.gain.setValueAtTime(options.volume||0.3,this.audioCtx.currentTime);gainNode.gain.exponentialRampToValueAtTime(0.001,this.audioCtx.currentTime+duration);duration=0.3;break;case 'fire_shot':oscillator.type='sawtooth';oscillator.frequency.setValueAtTime(900,this.audioCtx.currentTime);oscillator.frequency.exponentialRampToValueAtTime(300,this.audioCtx.currentTime+duration);gainNode.gain.setValueAtTime(options.volume||0.2,this.audioCtx.currentTime);gainNode.gain.exponentialRampToValueAtTime(0.001,this.audioCtx.currentTime+duration*1.1);duration=0.08;break;default:oscillator.type='noise';gainNode.gain.exponentialRampToValueAtTime(0.001,this.audioCtx.currentTime+duration);}oscillator.start(this.audioCtx.currentTime);oscillator.stop(this.audioCtx.currentTime+duration);}
            resumeContext(){if(this.audioCtx&&this.audioCtx.state==='suspended'){this.audioCtx.resume().then(()=>console.log("AudioContext resumed")).catch(e=>console.error("Error resuming AudioContext:",e));}}
        }

        class Player {
            constructor() {
                this.health = 100; this.maxHealth = 100;
                this.weapons = [ 
                    { name: 'Pistol', ammo: Infinity, damage: 50, fireRate: 300, spread: 0.02, pellets: 1, isHitscan: true, automatic: false, sound: 'pistol_shot' },
                    { name: 'Shotgun', ammo: 20, maxAmmo: 50, damage: 15, fireRate: 800, spread: 0.15, pellets: 8, isHitscan: true, automatic: false, sound: 'shotgun_shot' },
                    { name: 'MachineGun', ammo: 150, maxAmmo: 300, damage: 8, fireRate: 70, spread: 0.05, pellets: 1, isHitscan: true, automatic: true, sound: 'machinegun_shot' },
                    { name: 'PlasmaGun', ammo: 50, maxAmmo: 100, damage: 100, fireRate: 500, spread: 0, pellets: 1, projectileSpeed: 35, isHitscan: false, automatic: false, aoeRadius: 1.2, aoeDamage: 15, sound: 'plasma_shot' }
                ];
                this.currentWeaponIndex = 0; this.lastShotTime = 0; this.isShooting = false;
                this.playerCollider = new THREE.Box3(); this.updateCollider();
                this.isFrozen = false; this.freezeTimer = 0; this.freezeDuration = 3; // seconds
            }
            updateCollider() {this.playerCollider.setFromCenterAndSize(new THREE.Vector3(camera.position.x,camera.position.y-PLAYER_HEIGHT/2+0.1,camera.position.z),new THREE.Vector3(PLAYER_RADIUS*2,PLAYER_HEIGHT,PLAYER_RADIUS*2));}
            update(delta) { // Player specific update logic
                if (this.isFrozen) {
                    this.freezeTimer -= delta;
                    if (this.freezeTimer <= 0) {
                        this.unfreeze();
                    }
                }
            }
            freezePlayer() {
                if (this.isFrozen) return; // Already frozen, don't stack duration, just refresh
                this.isFrozen = true;
                this.freezeTimer = this.freezeDuration;
                currentPlayerSpeed = BASE_PLAYER_SPEED * 0.25; // Reduce speed
                frozenPlayerOverlay.style.display = 'block';
                if(audioManager) audioManager.playSound('freeze_hit');
                showGameMessage("You are FROZEN!", this.freezeDuration * 1000);
            }
            unfreeze() {
                this.isFrozen = false;
                this.freezeTimer = 0;
                currentPlayerSpeed = BASE_PLAYER_SPEED;
                frozenPlayerOverlay.style.display = 'none';
            }
            shoot(currentTime) { /* ... same ... */
                const weapon = this.weapons[this.currentWeaponIndex];
                if (currentTime-this.lastShotTime < weapon.fireRate) return;
                if (weapon.ammo===0 && weapon.name!=='Pistol') return;
                this.lastShotTime = currentTime;
                if (weapon.name!=='Pistol') weapon.ammo--;
                const direction=new THREE.Vector3(); camera.getWorldDirection(direction);
                const muzzleFlash=new THREE.Sprite(new THREE.SpriteMaterial({color:0xffff00,transparent:true,opacity:0.8}));
                const muzzleOffset=direction.clone().multiplyScalar(0.6); 
                muzzleFlash.position.copy(camera.position).add(muzzleOffset);
                muzzleFlash.scale.set(0.2,0.2,0.2); scene.add(muzzleFlash);
                temporaryEffects.push({mesh:muzzleFlash,lifetime:0.05});
                if(audioManager) audioManager.playSound(weapon.sound);
                if (weapon.isHitscan) {
                    for (let i=0;i<weapon.pellets;i++) {
                        const spreadDirection=direction.clone();
                        spreadDirection.x+=(Math.random()-0.5)*weapon.spread; spreadDirection.y+=(Math.random()-0.5)*weapon.spread; spreadDirection.z+=(Math.random()-0.5)*weapon.spread;
                        spreadDirection.normalize();
                        const raycaster=new THREE.Raycaster(camera.position,spreadDirection,0.01,100);
                        const objectsToTest = enemies.filter(e=>e.health>0).map(e=>e.collisionMesh).concat(gameManager.walls);
                        const intersects = raycaster.intersectObjects(objectsToTest, false); 
                        const shotGeo = new THREE.SphereGeometry(0.06, 4, 4); 
                        const shotMat = new THREE.MeshBasicMaterial({color: 0xffefaa, transparent:true, opacity:0.9});
                        const shotMesh = new THREE.Mesh(shotGeo, shotMat);
                        shotMesh.position.copy(camera.position).add(muzzleOffset);
                        let hitPointForVisual = camera.position.clone().add(spreadDirection.clone().multiplyScalar(70));
                        if (intersects.length > 0) {
                            const hit = intersects[0];
                            hitPointForVisual = hit.point.clone();
                            if (hit.object.userData.isEnemyCollider && hit.object.userData.enemyInstance) {
                                hit.object.userData.enemyInstance.takeDamage(weapon.damage, hit.point);
                            } else if (hit.object.userData.isWall) {
                                createImpactDecal(hit.point, hit.face.normal, 0xaaaaaa);
                            }
                        }
                        temporaryEffects.push({mesh:shotMesh, lifetime:0.1, velocity:spreadDirection.clone().multiplyScalar(150), isPhysicsParticle:true, target: hitPointForVisual, isVisualBullet: true});
                    }
                } else { 
                    const projectile = new Projectile(camera.position.clone().add(direction.clone().multiplyScalar(0.7)),direction.clone(),weapon.projectileSpeed,weapon.damage,true,weapon.aoeRadius,weapon.aoeDamage, 'plasma'); // Added type for projectile
                    bullets.push(projectile); scene.add(projectile.mesh);
                }
                updateUI();
            }
            switchWeapon(idx){ /* ... same as previous correct ... */ if(idx>=0&&idx<this.weapons.length){this.currentWeaponIndex=idx;updateUI();const newWeapon=this.weapons[this.currentWeaponIndex];if(newWeapon.automatic&&keys['MOUSE_LEFT']){this.isShooting=true;}else{this.isShooting=false;}}}
            takeDamage(amount){this.health-=amount;if(this.health<0)this.health=0;const dO=document.createElement('div');dO.style.cssText="position:absolute;top:0;left:0;width:100%;height:100%;background-color:rgba(255,0,0,0.3);pointer-events:none;";document.body.appendChild(dO);setTimeout(()=>document.body.removeChild(dO),100);if(audioManager)audioManager.playSound('player_hit');updateUI();if(this.health===0)gameManager.gameOver();}
            addHealth(amount){this.health=Math.min(this.health+amount,this.maxHealth);showGameMessage(`Health +${amount}!`,1500);if(audioManager)audioManager.playSound('pickup');updateUI();}
            addAmmo(weaponName,amount){const w=this.weapons.find(wp=>wp.name===weaponName);if(w&&w.name!=='Pistol'){w.ammo=Math.min(w.ammo+amount,w.maxAmmo);showGameMessage(`${w.name} Ammo +${amount}!`,1500);if(audioManager)audioManager.playSound('pickup',{frequency:1200});updateUI();}}
        }

        class Enemy {
            constructor(position, type = 'red') { // Added type
                this.type = type;
                this.enemySpecifics = gameManager.getEnemyStats(type);

                this.health = this.enemySpecifics.health;
                this.speed = this.enemySpecifics.speed;
                this.damage = this.enemySpecifics.damage; // Base damage for melee/red
                this.attackRange = 1.5; 
                this.shootRange = this.enemySpecifics.shootRange || 20; 
                this.lastAttackTime = 0; 
                this.attackCooldown = this.enemySpecifics.attackCooldown || 2000; 
                this.projectileType = this.enemySpecifics.projectileType || null;
                this.scoreValue = this.enemySpecifics.scoreValue || 1;

                let texture;
                if (type === 'green') texture = enemyGreenTexture;
                else if (type === 'blue') texture = enemyBlueTexture;
                else texture = enemyRedTexture;
                
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true, sizeAttenuation: true });
                this.spriteMesh = new THREE.Sprite(spriteMaterial);
                this.spriteMesh.position.copy(position);
                this.spriteMesh.position.y = PLAYER_HEIGHT / 2 - 0.3; 
                this.spriteMesh.scale.set(1.5, 1.5, 1.5);
                scene.add(this.spriteMesh);

                const enemyColliderWidth = 1.0, enemyColliderHeight = 1.6, enemyColliderDepth = 0.5;
                const collisionGeometry = new THREE.BoxGeometry(enemyColliderWidth, enemyColliderHeight, enemyColliderDepth);
                const collisionMaterial = new THREE.MeshBasicMaterial({ visible: DEBUG_ENEMY_COLLIDER, wireframe: DEBUG_ENEMY_COLLIDER, color: (type==='blue'?0x00ffff:(type==='green'?0x00ff00:0xff00ff)), transparent:true, opacity:0.5 });
                this.collisionMesh = new THREE.Mesh(collisionGeometry, collisionMaterial);
                this.collisionMesh.position.copy(this.spriteMesh.position);
                this.collisionMesh.userData = { isEnemyCollider: true, enemyInstance: this };
                scene.add(this.collisionMesh);
            }
            update(delta, playerPosition) { /* ... same movement, LOS ... */
                if (this.health <= 0) return;
                this.collisionMesh.position.copy(this.spriteMesh.position);
                const directionToPlayer = new THREE.Vector3().subVectors(playerPosition, this.spriteMesh.position);
                const distanceToPlayer = directionToPlayer.length();
                directionToPlayer.normalize();
                let hasLOS = false;
                if (distanceToPlayer < this.shootRange) { 
                    const raycaster = new THREE.Raycaster(this.spriteMesh.position,directionToPlayer,0,distanceToPlayer);
                    const intersects = raycaster.intersectObjects(gameManager.walls);
                    if (intersects.length===0 || intersects[0].distance>=distanceToPlayer-0.1) hasLOS=true;
                }
                if (hasLOS) {
                    if (distanceToPlayer > this.attackRange * (this.type === 'red' ? 1 : 0.8) ) { // Non-red enemies might keep slightly more distance
                        const moveVector = directionToPlayer.clone().multiplyScalar(this.speed*delta);
                        this.spriteMesh.position.add(moveVector); this.spriteMesh.position.y = PLAYER_HEIGHT/2-0.3; 
                    }
                    if (distanceToPlayer <= this.shootRange && (performance.now()-this.lastAttackTime > this.attackCooldown)) {
                        this.attackPlayer(directionToPlayer); // Pass direction for projectiles
                        this.lastAttackTime = performance.now();
                    }
                }
            }
            attackPlayer(directionToPlayer){
                if (this.type === 'red') { // Melee/basic hitscan
                    const dir=new THREE.Vector3().subVectors(camera.position,this.spriteMesh.position).normalize();
                    const rc=new THREE.Raycaster(this.spriteMesh.position,dir,0,this.attackRange * 1.5); // Red attack range
                    const wi=rc.intersectObjects(gameManager.walls);
                    if(!wi.length||wi[0].distance > new THREE.Vector3().subVectors(camera.position,this.spriteMesh.position).length()){
                         if(new THREE.Vector3().subVectors(camera.position,this.spriteMesh.position).length() <= this.attackRange * 1.2) {
                            player.takeDamage(this.damage);
                            // Simple visual for red enemy melee/close attack
                            const ap=new THREE.Mesh(new THREE.SphereGeometry(0.1,4,4),new THREE.MeshBasicMaterial({color:0xaa0000, transparent:true, opacity:0.6}));
                            ap.position.copy(this.spriteMesh.position).add(dir.clone().multiplyScalar(0.5)); scene.add(ap);
                            temporaryEffects.push({mesh:ap,lifetime:0.1});
                         }
                    }
                } else if (this.projectileType) { // Green and Blue shoot projectiles
                    const projectile = new Projectile(
                        this.spriteMesh.position.clone().add(directionToPlayer.clone().multiplyScalar(0.8)), // Start slightly in front
                        directionToPlayer,
                        this.enemySpecifics.projectileSpeed || 20,
                        this.enemySpecifics.projectileDamage || this.damage,
                        false, // isPlayerProjectile = false
                        0, 0, // AOE for enemy projectiles (can add later)
                        this.projectileType // 'snowflake' or 'fire'
                    );
                    bullets.push(projectile);
                    scene.add(projectile.mesh);
                    if (this.projectileType === 'fire' && audioManager) audioManager.playSound('fire_shot');
                    else if (this.projectileType === 'snowflake' && audioManager) audioManager.playSound('freeze_hit', {volume:0.2, duration:0.4});
                }
            }
            takeDamage(amount, hitPoint) { /* ... same ... */ if(this.health <= 0) return; this.health -= amount;createBloodSplat(hitPoint || this.spriteMesh.position, false, 0.8 + Math.random() * 0.4);if (this.health <= 0) { this.health = 0; this.die(); }}
            die() { /* ... same blood/gibs, but add scoreValue and guaranteed drop for special ... */
                scene.remove(this.spriteMesh); scene.remove(this.collisionMesh);
                const index = enemies.indexOf(this); if (index > -1) enemies.splice(index, 1);
                gameManager.enemyKilled(this.scoreValue); // Pass score value
                if(audioManager)audioManager.playSound('enemy_explode');
                for(let i=0;i<20;i++){const offset=new THREE.Vector3((Math.random()-0.5)*1.5,(Math.random()-0.5)*1.5,(Math.random()-0.5)*1.5);createBloodSplat(this.spriteMesh.position.clone().add(offset),Math.random()>0.3,Math.random()*0.7+0.3);}
                for (let i=0;i<4;i++){const gibMat=new THREE.MeshBasicMaterial({color:0x6a0dad,transparent:true,opacity:0.9});const gibSz=Math.random()*0.2+0.1;const gibGeo=new THREE.BoxGeometry(gibSz,gibSz,gibSz);const gib=new THREE.Mesh(gibGeo,gibMat);gib.position.copy(this.spriteMesh.position);const gibVel=new THREE.Vector3((Math.random()-0.5)*7,Math.random()*5+2,(Math.random()-0.5)*7);scene.add(gib);temporaryEffects.push({mesh:gib,lifetime:0.7+Math.random()*0.5,velocity:gibVel,isPhysicsParticle:true});}
                
                if (this.type === 'green' || this.type === 'blue') { // Guaranteed drop for special
                    const dropType = Math.random() < 0.5 ? 'health_small' : (Math.random() < 0.5 ? 'machinegun_ammo_small' : 'shotgun_ammo_small');
                    gameManager.spawnDroppedPickup(this.spriteMesh.position.clone(), dropType);
                } else if (Math.random() < 0.25) { // Regular red enemy drop chance
                    const dropTypeRoll = Math.random(); let pickupType;
                    if (dropTypeRoll < 0.4) pickupType = 'health_small'; else if (dropTypeRoll < 0.65) pickupType = 'shotgun_ammo_small'; else if (dropTypeRoll < 0.85) pickupType = 'machinegun_ammo_small'; else pickupType = 'plasma_ammo_small';
                    gameManager.spawnDroppedPickup(this.spriteMesh.position.clone(), pickupType);
                }
            }
        }
        
        class Projectile {
            constructor(pos,dir,spd,dmg,isPlayer,aoeR=0,aoeD=0, type = 'plasma'){ // Added projectile type
                this.type = type;
                this.pos=pos.clone();this.dir=dir.clone().normalize();this.spd=spd;this.dmg=dmg;this.isPlayer=isPlayer;this.aoeR=aoeR;this.aoeD=aoeD;this.life=3;
                
                let geo, mat, size = 0.1;
                if (type === 'plasma') {
                    geo=new THREE.SphereGeometry(size,6,6);
                    mat=new THREE.MeshBasicMaterial({color:0x00dd00,emissive:0x00ff00,emissiveIntensity:0.8,transparent:true,opacity:0.9});
                } else if (type === 'snowflake') {
                    size = 0.15;
                    geo=new THREE.OctahedronGeometry(size, 0); // Crystal-like shape
                    mat=new THREE.MeshStandardMaterial({color:0xADD8E6, emissive:0xADD8E6, emissiveIntensity:0.5, transparent:true, opacity:0.85, roughness:0.2, metalness:0.1});
                } else if (type === 'fire') {
                    size = 0.12;
                    geo=new THREE.SphereGeometry(size,5,5); // Slightly irregular sphere
                    mat=new THREE.MeshBasicMaterial({color:0xffA500, emissive:0xff4500, emissiveIntensity:0.9, transparent:true, opacity:0.9});
                }

                this.mesh=new THREE.Mesh(geo,mat);this.mesh.position.copy(this.pos);
                this.collider=new THREE.Sphere(this.pos,size);this.trailCounter=0;
            }
            update(delta){this.life-=delta;if(this.life<=0){this.destroy();return;}const moveDist=this.spd*delta;this.mesh.position.add(this.dir.clone().multiplyScalar(moveDist));this.collider.center.copy(this.mesh.position);this.trailCounter++;
                if(this.type === 'plasma' && this.trailCounter%2===0){const trailP=new THREE.Mesh(new THREE.SphereGeometry(0.05,4,4),new THREE.MeshBasicMaterial({color:0x00cc00,transparent:true,opacity:0.5}));trailP.position.copy(this.mesh.position).sub(this.dir.clone().multiplyScalar(0.2));scene.add(trailP);temporaryEffects.push({mesh:trailP,lifetime:0.15});}
                else if (this.type === 'fire' && this.trailCounter%1===0) { // More frequent trail for fire
                    const trailP=new THREE.Mesh(new THREE.SphereGeometry(0.04,3,3),new THREE.MeshBasicMaterial({color:0xff8c00,transparent:true,opacity:0.6}));trailP.position.copy(this.mesh.position).sub(this.dir.clone().multiplyScalar(0.15));scene.add(trailP);temporaryEffects.push({mesh:trailP,lifetime:0.1});
                } else if (this.type === 'snowflake' && this.trailCounter%3===0) {
                    const trailP=new THREE.Mesh(new THREE.SphereGeometry(0.03,3,3),new THREE.MeshBasicMaterial({color:0xD0FFFF,transparent:true,opacity:0.4}));trailP.position.copy(this.mesh.position).sub(this.dir.clone().multiplyScalar(0.1));scene.add(trailP);temporaryEffects.push({mesh:trailP,lifetime:0.2});
                }


                for(const w of gameManager.walls){if(this.collider.intersectsBox(new THREE.Box3().setFromObject(w))){this.handleImpact(this.mesh.position.clone());return;}}
                if(this.isPlayer){for(const e of enemies){if(e.health>0&&this.collider.intersectsBox(new THREE.Box3().setFromObject(e.collisionMesh))){this.handleImpact(e.collisionMesh.position.clone(),e);return;}}}
                else { // Enemy projectile hitting player
                    if (player && player.health > 0 && this.collider.intersectsBox(player.playerCollider)) {
                        this.handleImpact(player.playerCollider.getCenter(new THREE.Vector3()), null, true); // True for hitPlayer
                        return;
                    }
                }
            }
            handleImpact(impactPt,hitE=null, hitPlayer = false){
                if (this.type !== 'snowflake' || hitPlayer) { // Snowflake only explodes on player or wall
                    const expl=new THREE.Mesh(new THREE.SphereGeometry(this.aoeR>0?this.aoeR:(this.type==='fire'?0.3:0.4),8,8),new THREE.MeshBasicMaterial({color:(this.type==='fire'?0xff4500:0xffaa00),transparent:true,opacity:0.8}));
                    expl.position.copy(impactPt);scene.add(expl);temporaryEffects.push({mesh:expl,lifetime:0.2});
                }

                if(hitPlayer) {
                    if (this.type === 'snowflake') {
                        player.freezePlayer();
                    } else {
                        player.takeDamage(this.dmg);
                    }
                } else if(this.aoeR>0){if(this.isPlayer){enemies.forEach(e=>{if(e.health>0&&e.collisionMesh.position.distanceTo(impactPt)<=this.aoeR)e.takeDamage(this.aoeD,e.collisionMesh.position);});}else{/* Enemy AOE to player already handled by direct hit logic*/}}
                else if(hitE&&this.isPlayer){hitE.takeDamage(this.dmg,impactPt);}
                this.destroy();
            }
            destroy(){scene.remove(this.mesh);const i=bullets.indexOf(this);if(i>-1)bullets.splice(i,1);}
        }

        class Pickup { /* ... same ... */
            constructor(pos,type,isSmallDrop=false){this.type=type;this.mesh=null;this.collider=new THREE.Sphere(pos.clone(),isSmallDrop?0.4:0.6);this.collected=false;this.initialY=isSmallDrop?0.2:0.35;this.bobTime=Math.random()*Math.PI*2;let color,emissiveColor,boxSize=isSmallDrop?0.3:0.4;switch(type){case 'health':case 'health_small':color=0x00cc00;emissiveColor=0x00ff00;break;case 'shotgun_ammo':case 'shotgun_ammo_small':color=0xcc7a00;emissiveColor=0xff8c00;break;case 'machinegun_ammo_small':color=0x808080;emissiveColor=0xA9A9A9;break;case 'plasma_ammo':case 'plasma_ammo_small':color=0x0000cc;emissiveColor=0x3333ff;break;default:color=0xccc;emissiveColor=0xfff;}const geo=new THREE.BoxGeometry(boxSize,boxSize,boxSize);const mat=new THREE.MeshStandardMaterial({color:color,emissive:emissiveColor,emissiveIntensity:0.6,metalness:0.2,roughness:0.6});this.mesh=new THREE.Mesh(geo,mat);this.mesh.position.copy(pos);this.mesh.position.y=this.initialY;this.mesh.userData={isPickup:true,pickupInstance:this};scene.add(this.mesh);this.isSmallDrop=isSmallDrop;this.lifetime=isSmallDrop?10:Infinity;}
            collect(){if(this.collected)return;this.collected=true;scene.remove(this.mesh);const i=gameManager.pickups.indexOf(this);if(i>-1)gameManager.pickups.splice(i,1);switch(this.type){case 'health':player.addHealth(25);break;case 'health_small':player.addHealth(10);break;case 'shotgun_ammo':player.addAmmo('Shotgun',10);break;case 'shotgun_ammo_small':player.addAmmo('Shotgun',4);break;case 'machinegun_ammo_small':player.addAmmo('MachineGun',30);break;case 'plasma_ammo':player.addAmmo('PlasmaGun',20);break;case 'plasma_ammo_small':player.addAmmo('PlasmaGun',8);break;}}
            update(delta){if(this.collected)return;this.mesh.rotation.y+=delta*0.8;this.bobTime+=delta*2.5;this.mesh.position.y=this.initialY+Math.sin(this.bobTime)*0.1;if(this.isSmallDrop){this.lifetime-=delta;if(this.lifetime<=0){this.collected=true; scene.remove(this.mesh); const idx = gameManager.pickups.indexOf(this); if(idx > -1) gameManager.pickups.splice(idx,1); }}}
        }
        
        class GameManager {
            constructor(){
                this.enemiesKilled=0;this.difficultyLevel=0;this.maxEnemies=5;this.enemySpawnInterval=5000;this.lastSpawnTime=0;this.walls=[];this.pickups=[];
                this.currentDifficulty={enemyHealth:100,enemyMoveSpeed:2,enemyDamage:10}; // Base for red
                this.enemyTypes = {
                    'red': { health: 100, speed: 2, damage: 10, attackCooldown: 2000, scoreValue: 1, probability: 0.7 },
                    'green': { health: 150, speed: 2.8, damage: 12, projectileType: 'fire', projectileSpeed: 25, projectileDamage: 15, attackCooldown: 1000, shootRange: 22, scoreValue: 3, probability: 0.15 }, // Shoots fast fire
                    'blue': { health: 150, speed: 2.5, damage: 5, projectileType: 'snowflake', projectileSpeed: 18, projectileDamage: 5, attackCooldown: 2500, shootRange: 18, scoreValue: 3, probability: 0.15 }  // Shoots freeze
                };
            }
            getEnemyStats(type) { // Apply difficulty modifiers here
                const baseStats = this.enemyTypes[type] || this.enemyTypes['red'];
                return {
                    ...baseStats,
                    health: Math.floor(baseStats.health * (1 + this.difficultyLevel * 0.15)),
                    damage: Math.floor(baseStats.damage * (1 + this.difficultyLevel * 0.1)),
                    projectileDamage: Math.floor((baseStats.projectileDamage || baseStats.damage) * (1 + this.difficultyLevel * 0.1)),
                    speed: baseStats.speed * (1 + this.difficultyLevel * 0.05),
                };
            }
            enemyKilled(scoreValue = 1){this.enemiesKilled += scoreValue; this.updateDifficulty();updateUI();} // Updated
            updateDifficulty(){const nDL = Math.floor(this.enemiesKilled / 10);if(nDL > this.difficultyLevel){this.difficultyLevel=nDL;this.maxEnemies=5+nDL*2;this.enemySpawnInterval=Math.max(1000,5000-nDL*500);showGameMessage(`Difficulty Lvl ${this.difficultyLevel+1}! More Coming!`,2500);}}
            spawnEnemy(){
                if(enemies.length>=this.maxEnemies)return;
                let sX,sZ,vS=false;let att=0;
                while(!vS&&att<50){sX=Math.floor(Math.random()*MAP_DATA[0].length);sZ=Math.floor(Math.random()*MAP_DATA.length);if(MAP_DATA[sZ]&&MAP_DATA[sZ][sX]===0){const sP=new THREE.Vector3((sX-MAP_DATA[0].length/2)*TILE_SIZE+TILE_SIZE/2,0,(sZ-MAP_DATA.length/2)*TILE_SIZE+TILE_SIZE/2);if(camera&&sP.distanceTo(camera.position)>TILE_SIZE*3)vS=true;else if(!camera)vS=true;}att++;}
                if(vS){
                    const p=new THREE.Vector3((sX-MAP_DATA[0].length/2)*TILE_SIZE+TILE_SIZE/2,0,(sZ-MAP_DATA.length/2)*TILE_SIZE+TILE_SIZE/2);
                    // Decide enemy type
                    let enemyType = 'red';
                    const roll = Math.random();
                    let cumulativeProb = 0;
                    if (this.difficultyLevel > 0) { // Special enemies appear after first difficulty increase
                        cumulativeProb += this.enemyTypes.blue.probability;
                        if (roll < cumulativeProb) enemyType = 'blue';
                        else {
                            cumulativeProb += this.enemyTypes.green.probability;
                            if (roll < cumulativeProb) enemyType = 'green';
                        }
                    }
                    enemies.push(new Enemy(p, enemyType));
                }
            }
            spawnDroppedPickup(position,type){const pickup=new Pickup(position,type,true);this.pickups.push(pickup);}
            update(currentTime,delta){if(currentTime-this.lastSpawnTime>this.enemySpawnInterval){this.spawnEnemy();this.lastSpawnTime=currentTime;}for(let i=this.pickups.length-1;i>=0;i--)this.pickups[i].update(delta);}
            showTitleScreen() { /* ... same ... */ mainTitle.textContent="Splat!";statusMessage.textContent="Click to Blast!";actionButton.textContent="Start Game";actionButton.onclick=()=>this.startGame();exitButton.style.display='none';creditsText.style.display='block';instructionScrollerContainer.style.display='block';messageOverlay.style.display='flex';if(controls)controls.unlock();gameRunning=false;}
            startGame() { /* ... same ... */ instructionScrollerContainer.style.display='none';messageOverlay.style.display='none';if(controls)controls.lock();if(player&&player.health===0)this.restartGameInternal();if(audioManager)audioManager.resumeContext();}
            showPauseScreen() { /* ... same ... */ mainTitle.textContent="Paused";statusMessage.textContent="Take a breather, Slayer...";actionButton.textContent="Resume";actionButton.onclick=()=>{instructionScrollerContainer.style.display='none';messageOverlay.style.display='none';if(controls)controls.lock();};exitButton.textContent="Exit to Title";exitButton.style.display='inline-block';exitButton.onclick=()=>{this.showTitleScreen();this.resetEntireGameForTitle();};creditsText.style.display='none';instructionScrollerContainer.style.display='none';messageOverlay.style.display='flex';}
            gameOver() { /* ... same ... */ gameRunning=false;if(controls)controls.unlock();mainTitle.textContent="Game Over!";statusMessage.textContent=`You splatted ${this.enemiesKilled} demons!`;actionButton.textContent="Try Again?";actionButton.onclick=()=>this.restartGameInternal();exitButton.style.display='inline-block';exitButton.textContent="Back to Title";exitButton.onclick=()=>{this.showTitleScreen();this.resetEntireGameForTitle();};creditsText.style.display='none';instructionScrollerContainer.style.display='none';messageOverlay.style.display='flex';}
            resetEntireGameForTitle() { /* ... same player reset logic ... */ temporaryEffects.forEach(eff=>scene.remove(eff.mesh));temporaryEffects.length=0;enemies.forEach(e=>{scene.remove(e.spriteMesh); scene.remove(e.collisionMesh);});enemies.length=0;bullets.forEach(b=>scene.remove(b.mesh));bullets.length=0;this.pickups.forEach(p=>scene.remove(p.mesh));this.pickups.length=0;player = new Player(); this.enemiesKilled = 0; this.difficultyLevel = 0; this.maxEnemies = 5;this.enemySpawnInterval = 5000; this.lastSpawnTime = 0;const startPos = findStartPosition(); if(camera){camera.position.set(startPos.x, PLAYER_HEIGHT, startPos.z);camera.rotation.set(0,0,0);}if(controls && controls.euler){ controls.euler.set(0,0,0,'YXZ'); if(camera) camera.quaternion.setFromEuler(controls.euler); }buildLevel(); buildLevelPickups(); updateUI();currentPlayerSpeed = BASE_PLAYER_SPEED; player.unfreeze(); /* Ensure unfreeze on full reset */ }
            restartGameInternal(){console.log("Internal Restart..."); this.resetEntireGameForTitle(); instructionScrollerContainer.style.display = 'none'; messageOverlay.style.display = 'none';if (controls) controls.lock();}
        }
        
        function init() { /* ... same ... */
            console.log("Initializing game...");audioManager = new AudioManager(); audioManager.init().catch(e => console.error("Audio Init failed early:", e));
            scene=new THREE.Scene();scene.background=new THREE.Color(0x1a1a1a);scene.fog=new THREE.Fog(0x1a1a1a,TILE_SIZE*5,TILE_SIZE*10);
            camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);const sP=findStartPosition();camera.position.set(sP.x,PLAYER_HEIGHT,sP.z);
            renderer=new THREE.WebGLRenderer({canvas:document.getElementById('gameCanvas'),antialias:false});renderer.setSize(window.innerWidth,window.innerHeight);renderer.setPixelRatio(window.devicePixelRatio*0.75);
            const aL=new THREE.AmbientLight(0x707070);scene.add(aL);const dL=new THREE.DirectionalLight(0xffffff,0.5);dL.position.set(1,1,1).normalize();scene.add(dL);
            player=new Player(); gameManager=new GameManager(); controls=new PointerLockControls(camera,document.body);scene.add(controls.getObject());
            gameManager.showTitleScreen(); 
            if(controls){controls.addEventListener('lock',()=>{console.log("Controls locked.");if(messageOverlay.style.display!=='none'&&actionButton.textContent!=="Try Again?")messageOverlay.style.display='none';instructionScrollerContainer.style.display='none';gameRunning=true;lastTime=performance.now();if(audioManager)audioManager.resumeContext();});controls.addEventListener('unlock',()=>{console.log("Controls unlocked.");if(player&&player.health>0&&gameRunning)gameManager.showPauseScreen();gameRunning=false;});}
            buildLevel();buildLevelPickups();minimapCanvas.width = minimapCanvas.offsetWidth; minimapCanvas.height = minimapCanvas.offsetHeight;
            window.addEventListener('resize',onWindowResize,false);
            document.addEventListener('keydown',(e)=>{keys[e.code.toUpperCase()]=true;}); 
            document.addEventListener('keyup',(e)=>{keys[e.code.toUpperCase()]=false;});
            document.addEventListener('mousedown',(e)=>{if(controls&&controls.isLocked&&e.button===0&&player){keys['MOUSE_LEFT']=true;player.isShooting=true;const weapon=player.weapons[player.currentWeaponIndex];if(!weapon.automatic)player.shoot(performance.now());}if(audioManager)audioManager.resumeContext();});
            document.addEventListener('mouseup',(e)=>{if(e.button===0&&player){keys['MOUSE_LEFT']=false;if(player.weapons[player.currentWeaponIndex].automatic)player.isShooting=false;}});
            updateUI();console.log("Init complete.");
        }

        function findStartPosition(){for(let z=0;z<MAP_DATA.length;z++)for(let x=0;x<MAP_DATA[0].length;x++)if(MAP_DATA[z][x]===0)return{x:(x-MAP_DATA[0].length/2)*TILE_SIZE+TILE_SIZE/2,z:(z-MAP_DATA.length/2)*TILE_SIZE+TILE_SIZE/2};return{x:0,z:0};}
        function buildLevel(){const wG=new THREE.BoxGeometry(TILE_SIZE,WALL_HEIGHT,TILE_SIZE);const wM=new THREE.MeshLambertMaterial({map:wallTexture});gameManager.walls.forEach(w=>scene.remove(w));gameManager.walls=[];for(let z=0;z<MAP_DATA.length;z++)for(let x=0;x<MAP_DATA[0].length;x++)if(MAP_DATA[z][x]===1){const w=new THREE.Mesh(wG,wM);w.position.set((x-MAP_DATA[0].length/2)*TILE_SIZE+TILE_SIZE/2,WALL_HEIGHT/2,(z-MAP_DATA.length/2)*TILE_SIZE+TILE_SIZE/2);w.userData.isWall=true;scene.add(w);gameManager.walls.push(w);}const fG=new THREE.PlaneGeometry(MAP_DATA[0].length*TILE_SIZE,MAP_DATA.length*TILE_SIZE);const fM=new THREE.MeshLambertMaterial({map:floorTexture});const fl=new THREE.Mesh(fG,fM);fl.rotation.x=-Math.PI/2;scene.add(fl);const cG=new THREE.PlaneGeometry(MAP_DATA[0].length*TILE_SIZE,MAP_DATA.length*TILE_SIZE);const cM=new THREE.MeshLambertMaterial({map:ceilingTexture});const ce=new THREE.Mesh(cG,cM);ce.position.y=WALL_HEIGHT;ce.rotation.x=Math.PI/2;scene.add(ce);}
        function buildLevelPickups(){gameManager.pickups.forEach(p=>scene.remove(p.mesh));gameManager.pickups=[];for(let z=0;z<MAP_DATA.length;z++)for(let x=0;x<MAP_DATA[0].length;x++){const tT=MAP_DATA[z][x];const p=new THREE.Vector3((x-MAP_DATA[0].length/2)*TILE_SIZE+TILE_SIZE/2,0,(z-MAP_DATA.length/2)*TILE_SIZE+TILE_SIZE/2);let pT=null;if(tT===2)pT='health';else if(tT===3)pT='shotgun_ammo';else if(tT===4)pT='plasma_ammo';if(pT)gameManager.pickups.push(new Pickup(p,pT));}}
        class PointerLockControls extends THREE.EventDispatcher { /* ... same ... */ constructor(c,dE){super();this.camera=c;this.domElement=dE||document.body;this.isLocked=false;this.euler=new THREE.Euler(0,0,0,'YXZ');this.PI_2=Math.PI/2;this.minPolarAngle=0;this.maxPolarAngle=Math.PI;this._onMouseMove=this._onMouseMove.bind(this);this._onPointerlockChange=this._onPointerlockChange.bind(this);this._onPointerlockError=this._onPointerlockError.bind(this);this.connect();} _onMouseMove(e){if(this.isLocked===false)return;const mX=e.movementX||e.mozMovementX||e.webkitMovementX||0;const mY=e.movementY||e.mozMovementY||e.webkitMovementY||0;this.euler.setFromQuaternion(this.camera.quaternion);this.euler.y-=mX*MOUSE_SENSITIVITY;this.euler.x-=mY*MOUSE_SENSITIVITY;this.euler.x=Math.max(this.PI_2-this.maxPolarAngle,Math.min(this.PI_2-this.minPolarAngle,this.euler.x));this.camera.quaternion.setFromEuler(this.euler);this.dispatchEvent({type:'change'});} _onPointerlockChange(){if(document.pointerLockElement===this.domElement||document.mozPointerLockElement===this.domElement||document.webkitPointerLockElement===this.domElement){this.dispatchEvent({type:'lock'});this.isLocked=true;}else{this.dispatchEvent({type:'unlock'});this.isLocked=false;}} _onPointerlockError(e){console.error('PointerLockControls: Error.',e);} connect(){document.addEventListener('mousemove',this._onMouseMove,false);document.addEventListener('pointerlockchange',this._onPointerlockChange,false);document.addEventListener('mozpointerlockchange',this._onPointerlockChange,false);document.addEventListener('webkitpointerlockchange',this._onPointerlockChange,false);document.addEventListener('pointerlockerror',this._onPointerlockError,false);document.addEventListener('mozpointerlockerror',this._onPointerlockError,false);document.addEventListener('webkitpointerlockerror',this._onPointerlockError,false);} disconnect(){document.removeEventListener('mousemove',this._onMouseMove,false);document.removeEventListener('pointerlockchange',this._onPointerlockChange,false);document.removeEventListener('mozpointerlockchange',this._onPointerlockChange,false);document.removeEventListener('webkitpointerlockchange',this._onPointerlockChange,false);document.removeEventListener('pointerlockerror',this._onPointerlockError,false);document.removeEventListener('mozpointerlockerror',this._onPointerlockError,false);document.removeEventListener('webkitpointerlockerror',this._onPointerlockError,false);} dispose(){this.disconnect();} getObject(){return this.camera;} lock(){this.domElement.requestPointerLock=this.domElement.requestPointerLock||this.domElement.mozRequestPointerLock||this.domElement.webkitRequestPointerLock;if(this.domElement.requestPointerLock)this.domElement.requestPointerLock();else console.warn("requestPointerLock not available.");} unlock(){document.exitPointerLock=document.exitPointerLock||document.mozExitPointerLock||document.webkitExitPointerLock;if(document.exitPointerLock)document.exitPointerLock();else console.warn("exitPointerLock not available.");}}
        
        let minimapUpdateCounter = 0; const MINIMAP_UPDATE_INTERVAL = 5; 
        function animate() { /* ... main game loop ... */
            requestAnimationFrame(animate); 
            const currentTime = performance.now(); 
            animateScroller(currentTime); 
            if (!gameRunning && messageOverlay.style.display === 'none') return; 
            if (!gameRunning && messageOverlay.style.display !== 'none') { renderer.render(scene,camera); return; }
            
            let delta = (currentTime - lastTime) / 1000; lastTime = currentTime; 
            if (delta > 0.1) delta = 0.1; 

            player.update(delta); // Update player (for freeze timer etc)
            handleInput(delta);
            if (player.isShooting && player.weapons[player.currentWeaponIndex].automatic){const w=player.weapons[player.currentWeaponIndex];if(currentTime-player.lastShotTime>=w.fireRate)player.shoot(currentTime);}
            
            for(let i=bullets.length-1;i>=0;i--)bullets[i].update(delta);
            enemies.forEach(e=>e.update(delta,camera.position));
            for(let i=temporaryEffects.length-1;i>=0;i--){
                const effect = temporaryEffects[i]; effect.lifetime -= delta;
                if(effect.isPhysicsParticle && effect.mesh){
                    if (effect.isVisualBullet && effect.target) { 
                        const dirToTarget = new THREE.Vector3().subVectors(effect.target, effect.mesh.position).normalize();
                        const distToTarget = effect.mesh.position.distanceTo(effect.target);
                        const moveDist = Math.min(distToTarget, effect.velocity.length() * delta);
                        effect.mesh.position.add(dirToTarget.multiplyScalar(moveDist));
                        if (distToTarget < 0.1) effect.lifetime = 0; 
                    } else { 
                        effect.mesh.position.add(effect.velocity.clone().multiplyScalar(delta));
                        effect.velocity.y -= 15 * delta;
                        if(effect.target && effect.mesh.position.distanceTo(effect.target)<0.2 && effect.lifetime>0.1) effect.lifetime=0.1;
                    }
                    if(effect.mesh.position.y < -1 && !effect.isVisualBullet) effect.lifetime = 0; 
                }
                if(effect.lifetime<=0){scene.remove(effect.mesh);temporaryEffects.splice(i,1);}
            }
            gameManager.update(currentTime,delta); if(player)player.updateCollider(); 
            minimapUpdateCounter++; if (minimapUpdateCounter >= MINIMAP_UPDATE_INTERVAL) { drawMinimap(); minimapUpdateCounter = 0; }
            renderer.render(scene,camera);
        }
        function handleInput(delta){ /* ... WASD movement, Q/E look, Digit weapon switch ... */
            if(!controls||!controls.isLocked||!player)return;const mS=currentPlayerSpeed*delta;const pP=camera.position.clone(); // Use currentPlayerSpeed
            if(keys['KEYW'])controls.getObject().translateZ(-mS);if(keys['KEYS'])controls.getObject().translateZ(mS); 
            if(keys['KEYA'])controls.getObject().translateX(-mS);if(keys['KEYD'])controls.getObject().translateX(mS); 
            camera.position.y=PLAYER_HEIGHT;const tP=camera.position.clone();player.updateCollider();let cO=false;
            for(const w of gameManager.walls){if(player.playerCollider.intersectsBox(new THREE.Box3().setFromObject(w))){cO=true;break;}}
            if(cO){camera.position.copy(pP);camera.position.z=tP.z;player.updateCollider();let zC=false;for(const w of gameManager.walls)if(player.playerCollider.intersectsBox(new THREE.Box3().setFromObject(w))){zC=true;break;}if(zC)camera.position.z=pP.z;camera.position.x=tP.x;player.updateCollider();let xC=false;for(const w of gameManager.walls)if(player.playerCollider.intersectsBox(new THREE.Box3().setFromObject(w))){xC=true;break;}if(xC)camera.position.x=pP.x;player.updateCollider();}
            for(let i=gameManager.pickups.length-1;i>=0;i--){const p=gameManager.pickups[i];if(!p.collected&&player.playerCollider.intersectsSphere(p.collider))p.collect();}
            if(keys['DIGIT1'])player.switchWeapon(0);if(keys['DIGIT2'])player.switchWeapon(1);if(keys['DIGIT3'])player.switchWeapon(2);if(keys['DIGIT4'])player.switchWeapon(3);
            if(keys['KEYQ']) controls.getObject().rotation.y += BASE_PLAYER_SPEED * 0.005; // Q/E use base speed for turning consistency
            if(keys['KEYE']) controls.getObject().rotation.y -= BASE_PLAYER_SPEED * 0.005; 
        }
        
        function createBloodSplat(pos,lg=false,scM=1){const sM=new THREE.SpriteMaterial({color:0xff0000,transparent:true,opacity:0.9});const s=new THREE.Sprite(sM);s.position.copy(pos);s.position.x+=(Math.random()-0.5)*(lg?1:0.3);s.position.y+=(Math.random()-0.5)*(lg?1:0.3);s.position.z+=(Math.random()-0.5)*(lg?1:0.3);const sc=(Math.random()*0.3+0.1)*(lg?2:1)*scM;s.scale.set(sc,sc,sc);scene.add(s);temporaryEffects.push({mesh:s,lifetime:0.4+Math.random()*0.3});}
        function createImpactDecal(pos,nml,clr=0x888){const dM=new THREE.MeshBasicMaterial({color:clr,transparent:true,opacity:0.7,polygonOffset:true,polygonOffsetFactor:-4});const dG=new THREE.PlaneGeometry(0.3,0.3);const d=new THREE.Mesh(dG,dM);d.position.copy(pos);d.position.add(nml.clone().multiplyScalar(0.01));d.lookAt(pos.clone().add(nml));scene.add(d);temporaryEffects.push({mesh:d,lifetime:2});}
        function drawMinimap() { /* ... same ... */
            const mapWidth=MAP_DATA[0].length,mapHeight=MAP_DATA.length,miniTileSizeX=minimapCanvas.width/mapWidth,miniTileSizeY=minimapCanvas.height/mapHeight;minimapCtx.clearRect(0,0,minimapCanvas.width,minimapCanvas.height);
            for(let y=0;y<mapHeight;y++)for(let x=0;x<mapWidth;x++){if(MAP_DATA[y][x]===1)minimapCtx.fillStyle='#555';else if(MAP_DATA[y][x]>=2&&MAP_DATA[y][x]<=4)minimapCtx.fillStyle='#333';else minimapCtx.fillStyle='#222';minimapCtx.fillRect(x*miniTileSizeX,y*miniTileSizeY,miniTileSizeX,miniTileSizeY);}
            const worldToMinimap=(wX,wZ)=>{const mOX=-(mapWidth/2)*TILE_SIZE,mOZ=-(mapHeight/2)*TILE_SIZE;return{x:((wX-mOX)/(mapWidth*TILE_SIZE))*minimapCanvas.width,y:((wZ-mOZ)/(mapHeight*TILE_SIZE))*minimapCanvas.height};};
            if(player&&camera){const pP=worldToMinimap(camera.position.x,camera.position.z);minimapCtx.fillStyle='lime';minimapCtx.beginPath();minimapCtx.arc(pP.x,pP.y,3,0,Math.PI*2);minimapCtx.fill();const pD=new THREE.Vector3();camera.getWorldDirection(pD);minimapCtx.strokeStyle='lime';minimapCtx.lineWidth=1;minimapCtx.beginPath();minimapCtx.moveTo(pP.x,pP.y);minimapCtx.lineTo(pP.x+pD.x*8,pP.y+pD.z*8);minimapCtx.stroke();}
            minimapCtx.fillStyle='red';enemies.forEach(e=>{if(e.health>0){const eP=worldToMinimap(e.spriteMesh.position.x,e.spriteMesh.position.z);let enemyColor='red';if(e.type==='green')enemyColor='lime';else if(e.type==='blue')enemyColor='cyan';minimapCtx.fillStyle=enemyColor;minimapCtx.beginPath();minimapCtx.arc(eP.x,eP.y,2.5,0,Math.PI*2);minimapCtx.fill();}});
            minimapCtx.fillStyle='cyan';gameManager.pickups.forEach(p=>{if(!p.collected&&!p.isSmallDrop){const pP=worldToMinimap(p.mesh.position.x,p.mesh.position.z);minimapCtx.fillRect(pP.x-2,pP.y-2,4,4);}});
        }
        function updateUI(){
            if(!player||!gameManager)return;
            const healthPercent = (player.health / player.maxHealth) * 100;
            healthBarInner.style.width = `${healthPercent}%`;
            healthText.textContent = `${Math.round(healthPercent)}%`;
            if (healthPercent < 30) healthBarInner.style.backgroundColor = '#cc0000'; // Red when low
            else if (healthPercent < 60) healthBarInner.style.backgroundColor = '#cccc00'; // Yellow when medium
            else healthBarInner.style.backgroundColor = '#00cc00'; // Green when high

            const cW=player.weapons[player.currentWeaponIndex];weaponDisplay.textContent=`W:${cW.name.substring(0,6)}`;ammoDisplay.textContent=`A:${cW.ammo===Infinity?'':cW.ammo}`;scoreDisplay.textContent=`K:${gameManager.enemiesKilled}`;
        }
        function showGameMessage(txt,dur=1500){gameMessageCenter.textContent=txt; gameMessageCenter.style.display='block';setTimeout(()=>{if(gameMessageCenter.textContent===txt)gameMessageCenter.style.display='none';},dur);}
        function onWindowResize(){camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight);minimapCanvas.width=minimapCanvas.offsetWidth;minimapCanvas.height=minimapCanvas.offsetHeight;}
        init(); animate(); console.log("Loop started.");
    </script>
</body>
</html>
